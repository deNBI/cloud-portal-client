#
# Autogenerated by Thrift Compiler (0.15.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface(object):
    """
    This VirtualMachiine service deploys methods for creating,deleting,stopping etc. VirtualMachines in Openstack.

    """
    def check_version(self, version):
        """
        Parameters:
         - version

        """
        pass

    def get_client_version(self):
        """
        Get Client version.
        Returns Version of the client

        """
        pass

    def get_gateway_ip(self):
        """
        Gets the gateway ip.

        """
        pass

    def get_calculation_values(self):
        pass

    def import_keypair(self, keyname, public_key):
        """
        Import Key to openstack.
        Returns : keypair

        Parameters:
         - keyname: Name for the keypair
         - public_key: The public key

        """
        pass

    def get_vm_ports(self, openstack_id):
        """
        Get Ip and Port of server
        Returns:  {'IP': ip, 'PORT': port,'UDP':udp}

        Parameters:
         - openstack_id: Id of server

        """
        pass

    def get_flavors(self):
        """
        Get Flavors.
        Returns: List of flavor instances.

        """
        pass

    def get_images(self):
        """
        Get Images.
        Returns: List of Image instances.

        """
        pass

    def get_public_images(self):
        """
        Get Images.
        Returns: List of public Image instances.

        """
        pass

    def get_private_images(self):
        """
        Get Images.
        Returns: List of private Image instances.

        """
        pass

    def get_image(self, openstack_id):
        """
        Get an image with tag.
        Returns: image.

        Parameters:
         - openstack_id

        """
        pass

    def get_images_by_filter(self, filter_json):
        """
        Get Images and filter by list of strings.
        Returns: List of Image instances.

        Parameters:
         - filter_json

        """
        pass

    def get_volume(self, volume_id):
        """
        Parameters:
         - volume_id

        """
        pass

    def get_volumes_by_ids(self, volume_ids):
        """
        Parameters:
         - volume_ids

        """
        pass

    def resize_volume(self, volume_id, size):
        """
        Parameters:
         - volume_id
         - size

        """
        pass

    def delete_server(self, openstack_id):
        """
        Delete server.
        Returns: True if deleted, False if not

        Parameters:
         - openstack_id: Id of the server.

        """
        pass

    def start_server(self, flavor, image, public_key, servername, metadata, research_environment, volume_ids_path_new, volume_ids_path_attach, additional_keys):
        """
        Parameters:
         - flavor: Name of the  Flavor to use.
         - image: Name of the image to use.
         - public_key: Public Key to use
         - servername: Name for the new server
         - metadata: Metadata for the new instance
         - research_environment
         - volume_ids_path_new
         - volume_ids_path_attach
         - additional_keys

        """
        pass

    def bibigrid_available(self):
        pass

    def detach_ip_from_server(self, server_id, floating_ip):
        """
        Parameters:
         - server_id
         - floating_ip

        """
        pass

    def start_server_with_custom_key(self, flavor, image, servername, metadata, research_environment, volume_ids_path_new, volume_ids_path_attach):
        """
        Start a new server with custom key for ansible.

        Parameters:
         - flavor: Name of the  Flavor to use.
         - image: Name of the image to use.
         - servername: Name for the new server
         - metadata: Metadata for the new instance
         - research_environment
         - volume_ids_path_new
         - volume_ids_path_attach

        """
        pass

    def exist_server(self, name):
        """
        Check if there is an instance with name

        Parameters:
         - name

        """
        pass

    def create_and_deploy_playbook(self, public_key, playbooks_information, openstack_id):
        """
        Create and deploy an anaconda ansible playbook

        Parameters:
         - public_key
         - playbooks_information
         - openstack_id

        """
        pass

    def get_playbook_logs(self, openstack_id):
        """
        Get the logs from a playbook run

        Parameters:
         - openstack_id

        """
        pass

    def has_forc(self):
        """
        Get boolean if client has backend url configured

        """
        pass

    def get_forc_url(self):
        pass

    def create_backend(self, elixir_id, user_key_url, template, upstream_url):
        """
        Create a backend

        Parameters:
         - elixir_id
         - user_key_url
         - template
         - upstream_url

        """
        pass

    def get_backends(self):
        """
        Get all backends

        """
        pass

    def get_backends_by_owner(self, elixir_id):
        """
        Get all backends by owner

        Parameters:
         - elixir_id

        """
        pass

    def get_backends_by_template(self, template):
        """
        Get all backends by template

        Parameters:
         - template

        """
        pass

    def get_backend_by_id(self, id):
        """
        Get a backend by id

        Parameters:
         - id

        """
        pass

    def delete_backend(self, id):
        """
        Delete a backend

        Parameters:
         - id

        """
        pass

    def add_user_to_backend(self, backend_id, owner_id, user_id):
        """
        Add a user to a backend

        Parameters:
         - backend_id
         - owner_id
         - user_id

        """
        pass

    def get_users_from_backend(self, backend_id):
        """
        Get users from a backend

        Parameters:
         - backend_id

        """
        pass

    def delete_user_from_backend(self, backend_id, owner_id, user_id):
        """
        Delete user from a backend

        Parameters:
         - backend_id
         - owner_id
         - user_id

        """
        pass

    def get_templates(self):
        pass

    def get_allowed_templates(self):
        pass

    def get_templates_by_template(self, template_name):
        """
        Parameters:
         - template_name

        """
        pass

    def check_template(self, template_name, template_version):
        """
        Parameters:
         - template_name
         - template_version

        """
        pass

    def add_udp_security_group(self, server_id):
        """
        Adds a security group to a server

        Parameters:
         - server_id: OpenStack id of the server

        """
        pass

    def get_servers(self):
        """
        Get all servers.
        Returns: List of server instances.

        """
        pass

    def get_servers_by_ids(self, server_ids):
        """
        * Get list of servers by ids
           *

        Parameters:
         - server_ids

        """
        pass

    def check_server_task_state(self, openstack_id):
        """
        Parameters:
         - openstack_id

        """
        pass

    def get_servers_by_bibigrid_id(self, bibigrid_id):
        """
        * Get servers by bibigrid cluster id.
           *

        Parameters:
         - bibigrid_id

        """
        pass

    def scale_up_cluster(self, cluster_id, image, flavor, count, names, start_idx, batch_idx):
        """
        Parameters:
         - cluster_id
         - image
         - flavor
         - count
         - names
         - start_idx
         - batch_idx

        """
        pass

    def add_cluster_machine(self, cluster_id, cluster_user, cluster_group_id, image, flavor, name, key_name, batch_idx, worker_idx):
        """
        Parameters:
         - cluster_id
         - cluster_user
         - cluster_group_id
         - image
         - flavor
         - name
         - key_name
         - batch_idx
         - worker_idx

        """
        pass

    def get_cluster_info(self, cluster_id):
        """
        Parameters:
         - cluster_id

        """
        pass

    def get_cluster_status(self, cluster_id):
        """
        Parameters:
         - cluster_id

        """
        pass

    def get_server(self, openstack_id):
        """
        Get a Server.
        Returns: A server instance.

        Parameters:
         - openstack_id: Id of the server.

        """
        pass

    def stop_server(self, openstack_id):
        """
        Stop a Server.
        Returns: True if stopped, False if not.

        Parameters:
         - openstack_id: Id of the server.

        """
        pass

    def create_snapshot(self, openstack_id, name, elixir_id, base_tags, description):
        """
        Create Snapshot.
        Returns: Id of new Snapshot


        Parameters:
         - openstack_id: Id of the server
         - name: Name of new Snapshot
         - elixir_id: Elixir-Id of the user who requested creation of Snapshot
         - base_tags: Tags with which the servers image is also tagged ( for connection information at the webapp)
         - description: Description of the new snapshot

        """
        pass

    def get_limits(self):
        """
        Get Limits of OpenStack Projekt from client.
        Returns: {'maxTotalVolumes': maxTotalVolumes, 'maxTotalVolumeGigabytes': maxTotalVolumeGigabytes,
                  'maxTotalInstances': maxTotalInstances, 'totalRamUsed': totalRamUsed,
                 'totalInstancesUsed': totalInstancesUsed}

        """
        pass

    def start_cluster(self, public_key, master_instance, worker_instance, user):
        """
        Parameters:
         - public_key
         - master_instance
         - worker_instance
         - user

        """
        pass

    def terminate_cluster(self, cluster_id):
        """
        Parameters:
         - cluster_id

        """
        pass

    def delete_image(self, image_id):
        """
        Delete Image.
        Return: True if deleted, False if not

        Parameters:
         - image_id: Id of image

        """
        pass

    def delete_volume_attachment(self, volume_id, server_id):
        """
        Delete volume attachment
        Return: True if deleted, False if not

        Parameters:
         - volume_id: Id of the attached volume
         - server_id: Id of the server where the volume is attached

        """
        pass

    def delete_volume(self, volume_id):
        """
        Delete volume.
        Returns:  True if deleted, False if not

        Parameters:
         - volume_id

        """
        pass

    def attach_volume_to_server(self, openstack_id, volume_id):
        """
        Attach volume to server.
        Returns:  True if attached, False if not

        Parameters:
         - openstack_id: Id of server
         - volume_id: Id of volume

        """
        pass

    def check_server_status(self, openstack_id):
        """
        Check status of server.
        Returns: server instance

        Parameters:
         - openstack_id: Id of the server

        """
        pass

    def resume_server(self, openstack_id):
        """
        Resume Server.
        Returns: True if resumed False if not

        Parameters:
         - openstack_id: Id of the server

        """
        pass

    def create_volume(self, volume_name, volume_storage, metadata):
        """
        Create volume.
        Returns: Id of new volume

        Parameters:
         - volume_name: Name of volume
         - volume_storage: Diskspace in GB for new volume
         - metadata: Metadata for the new volume

        """
        pass

    def reboot_server(self, openstack_id, reboot_type):
        """
        Reboot server.
        Returns: True if rebooted False if not

        Parameters:
         - openstack_id: Id of the server
         - reboot_type: HARD or SOFT

        """
        pass


class Client(Iface):
    """
    This VirtualMachiine service deploys methods for creating,deleting,stopping etc. VirtualMachines in Openstack.

    """
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def check_version(self, version):
        """
        Parameters:
         - version

        """
        self.send_check_version(version)
        return self.recv_check_version()

    def send_check_version(self, version):
        self._oprot.writeMessageBegin('check_version', TMessageType.CALL, self._seqid)
        args = check_version_args()
        args.version = version
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_check_version(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = check_version_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "check_version failed: unknown result")

    def get_client_version(self):
        """
        Get Client version.
        Returns Version of the client

        """
        self.send_get_client_version()
        return self.recv_get_client_version()

    def send_get_client_version(self):
        self._oprot.writeMessageBegin('get_client_version', TMessageType.CALL, self._seqid)
        args = get_client_version_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_client_version(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_client_version_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_client_version failed: unknown result")

    def get_gateway_ip(self):
        """
        Gets the gateway ip.

        """
        self.send_get_gateway_ip()
        return self.recv_get_gateway_ip()

    def send_get_gateway_ip(self):
        self._oprot.writeMessageBegin('get_gateway_ip', TMessageType.CALL, self._seqid)
        args = get_gateway_ip_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_gateway_ip(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_gateway_ip_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_gateway_ip failed: unknown result")

    def get_calculation_values(self):
        self.send_get_calculation_values()
        return self.recv_get_calculation_values()

    def send_get_calculation_values(self):
        self._oprot.writeMessageBegin('get_calculation_values', TMessageType.CALL, self._seqid)
        args = get_calculation_values_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_calculation_values(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_calculation_values_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_calculation_values failed: unknown result")

    def import_keypair(self, keyname, public_key):
        """
        Import Key to openstack.
        Returns : keypair

        Parameters:
         - keyname: Name for the keypair
         - public_key: The public key

        """
        self.send_import_keypair(keyname, public_key)
        return self.recv_import_keypair()

    def send_import_keypair(self, keyname, public_key):
        self._oprot.writeMessageBegin('import_keypair', TMessageType.CALL, self._seqid)
        args = import_keypair_args()
        args.keyname = keyname
        args.public_key = public_key
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_import_keypair(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = import_keypair_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "import_keypair failed: unknown result")

    def get_vm_ports(self, openstack_id):
        """
        Get Ip and Port of server
        Returns:  {'IP': ip, 'PORT': port,'UDP':udp}

        Parameters:
         - openstack_id: Id of server

        """
        self.send_get_vm_ports(openstack_id)
        return self.recv_get_vm_ports()

    def send_get_vm_ports(self, openstack_id):
        self._oprot.writeMessageBegin('get_vm_ports', TMessageType.CALL, self._seqid)
        args = get_vm_ports_args()
        args.openstack_id = openstack_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_vm_ports(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_vm_ports_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_vm_ports failed: unknown result")

    def get_flavors(self):
        """
        Get Flavors.
        Returns: List of flavor instances.

        """
        self.send_get_flavors()
        return self.recv_get_flavors()

    def send_get_flavors(self):
        self._oprot.writeMessageBegin('get_flavors', TMessageType.CALL, self._seqid)
        args = get_flavors_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_flavors(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_flavors_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_flavors failed: unknown result")

    def get_images(self):
        """
        Get Images.
        Returns: List of Image instances.

        """
        self.send_get_images()
        return self.recv_get_images()

    def send_get_images(self):
        self._oprot.writeMessageBegin('get_images', TMessageType.CALL, self._seqid)
        args = get_images_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_images(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_images_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_images failed: unknown result")

    def get_public_images(self):
        """
        Get Images.
        Returns: List of public Image instances.

        """
        self.send_get_public_images()
        return self.recv_get_public_images()

    def send_get_public_images(self):
        self._oprot.writeMessageBegin('get_public_images', TMessageType.CALL, self._seqid)
        args = get_public_images_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_public_images(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_public_images_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_public_images failed: unknown result")

    def get_private_images(self):
        """
        Get Images.
        Returns: List of private Image instances.

        """
        self.send_get_private_images()
        return self.recv_get_private_images()

    def send_get_private_images(self):
        self._oprot.writeMessageBegin('get_private_images', TMessageType.CALL, self._seqid)
        args = get_private_images_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_private_images(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_private_images_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_private_images failed: unknown result")

    def get_image(self, openstack_id):
        """
        Get an image with tag.
        Returns: image.

        Parameters:
         - openstack_id

        """
        self.send_get_image(openstack_id)
        return self.recv_get_image()

    def send_get_image(self, openstack_id):
        self._oprot.writeMessageBegin('get_image', TMessageType.CALL, self._seqid)
        args = get_image_args()
        args.openstack_id = openstack_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_image(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_image_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_image failed: unknown result")

    def get_images_by_filter(self, filter_json):
        """
        Get Images and filter by list of strings.
        Returns: List of Image instances.

        Parameters:
         - filter_json

        """
        self.send_get_images_by_filter(filter_json)
        return self.recv_get_images_by_filter()

    def send_get_images_by_filter(self, filter_json):
        self._oprot.writeMessageBegin('get_images_by_filter', TMessageType.CALL, self._seqid)
        args = get_images_by_filter_args()
        args.filter_json = filter_json
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_images_by_filter(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_images_by_filter_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_images_by_filter failed: unknown result")

    def get_volume(self, volume_id):
        """
        Parameters:
         - volume_id

        """
        self.send_get_volume(volume_id)
        return self.recv_get_volume()

    def send_get_volume(self, volume_id):
        self._oprot.writeMessageBegin('get_volume', TMessageType.CALL, self._seqid)
        args = get_volume_args()
        args.volume_id = volume_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_volume(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_volume_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_volume failed: unknown result")

    def get_volumes_by_ids(self, volume_ids):
        """
        Parameters:
         - volume_ids

        """
        self.send_get_volumes_by_ids(volume_ids)
        return self.recv_get_volumes_by_ids()

    def send_get_volumes_by_ids(self, volume_ids):
        self._oprot.writeMessageBegin('get_volumes_by_ids', TMessageType.CALL, self._seqid)
        args = get_volumes_by_ids_args()
        args.volume_ids = volume_ids
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_volumes_by_ids(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_volumes_by_ids_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_volumes_by_ids failed: unknown result")

    def resize_volume(self, volume_id, size):
        """
        Parameters:
         - volume_id
         - size

        """
        self.send_resize_volume(volume_id, size)
        return self.recv_resize_volume()

    def send_resize_volume(self, volume_id, size):
        self._oprot.writeMessageBegin('resize_volume', TMessageType.CALL, self._seqid)
        args = resize_volume_args()
        args.volume_id = volume_id
        args.size = size
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_resize_volume(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = resize_volume_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "resize_volume failed: unknown result")

    def delete_server(self, openstack_id):
        """
        Delete server.
        Returns: True if deleted, False if not

        Parameters:
         - openstack_id: Id of the server.

        """
        self.send_delete_server(openstack_id)
        return self.recv_delete_server()

    def send_delete_server(self, openstack_id):
        self._oprot.writeMessageBegin('delete_server', TMessageType.CALL, self._seqid)
        args = delete_server_args()
        args.openstack_id = openstack_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_delete_server(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = delete_server_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        if result.c is not None:
            raise result.c
        raise TApplicationException(TApplicationException.MISSING_RESULT, "delete_server failed: unknown result")

    def start_server(self, flavor, image, public_key, servername, metadata, research_environment, volume_ids_path_new, volume_ids_path_attach, additional_keys):
        """
        Parameters:
         - flavor: Name of the  Flavor to use.
         - image: Name of the image to use.
         - public_key: Public Key to use
         - servername: Name for the new server
         - metadata: Metadata for the new instance
         - research_environment
         - volume_ids_path_new
         - volume_ids_path_attach
         - additional_keys

        """
        self.send_start_server(flavor, image, public_key, servername, metadata, research_environment, volume_ids_path_new, volume_ids_path_attach, additional_keys)
        return self.recv_start_server()

    def send_start_server(self, flavor, image, public_key, servername, metadata, research_environment, volume_ids_path_new, volume_ids_path_attach, additional_keys):
        self._oprot.writeMessageBegin('start_server', TMessageType.CALL, self._seqid)
        args = start_server_args()
        args.flavor = flavor
        args.image = image
        args.public_key = public_key
        args.servername = servername
        args.metadata = metadata
        args.research_environment = research_environment
        args.volume_ids_path_new = volume_ids_path_new
        args.volume_ids_path_attach = volume_ids_path_attach
        args.additional_keys = additional_keys
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_start_server(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = start_server_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        if result.r is not None:
            raise result.r
        if result.s is not None:
            raise result.s
        if result.n is not None:
            raise result.n
        if result.i is not None:
            raise result.i
        if result.f is not None:
            raise result.f
        if result.o is not None:
            raise result.o
        raise TApplicationException(TApplicationException.MISSING_RESULT, "start_server failed: unknown result")

    def bibigrid_available(self):
        self.send_bibigrid_available()
        return self.recv_bibigrid_available()

    def send_bibigrid_available(self):
        self._oprot.writeMessageBegin('bibigrid_available', TMessageType.CALL, self._seqid)
        args = bibigrid_available_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_bibigrid_available(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = bibigrid_available_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "bibigrid_available failed: unknown result")

    def detach_ip_from_server(self, server_id, floating_ip):
        """
        Parameters:
         - server_id
         - floating_ip

        """
        self.send_detach_ip_from_server(server_id, floating_ip)
        return self.recv_detach_ip_from_server()

    def send_detach_ip_from_server(self, server_id, floating_ip):
        self._oprot.writeMessageBegin('detach_ip_from_server', TMessageType.CALL, self._seqid)
        args = detach_ip_from_server_args()
        args.server_id = server_id
        args.floating_ip = floating_ip
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_detach_ip_from_server(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = detach_ip_from_server_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "detach_ip_from_server failed: unknown result")

    def start_server_with_custom_key(self, flavor, image, servername, metadata, research_environment, volume_ids_path_new, volume_ids_path_attach):
        """
        Start a new server with custom key for ansible.

        Parameters:
         - flavor: Name of the  Flavor to use.
         - image: Name of the image to use.
         - servername: Name for the new server
         - metadata: Metadata for the new instance
         - research_environment
         - volume_ids_path_new
         - volume_ids_path_attach

        """
        self.send_start_server_with_custom_key(flavor, image, servername, metadata, research_environment, volume_ids_path_new, volume_ids_path_attach)
        return self.recv_start_server_with_custom_key()

    def send_start_server_with_custom_key(self, flavor, image, servername, metadata, research_environment, volume_ids_path_new, volume_ids_path_attach):
        self._oprot.writeMessageBegin('start_server_with_custom_key', TMessageType.CALL, self._seqid)
        args = start_server_with_custom_key_args()
        args.flavor = flavor
        args.image = image
        args.servername = servername
        args.metadata = metadata
        args.research_environment = research_environment
        args.volume_ids_path_new = volume_ids_path_new
        args.volume_ids_path_attach = volume_ids_path_attach
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_start_server_with_custom_key(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = start_server_with_custom_key_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        if result.r is not None:
            raise result.r
        if result.s is not None:
            raise result.s
        if result.n is not None:
            raise result.n
        if result.i is not None:
            raise result.i
        if result.f is not None:
            raise result.f
        if result.o is not None:
            raise result.o
        raise TApplicationException(TApplicationException.MISSING_RESULT, "start_server_with_custom_key failed: unknown result")

    def exist_server(self, name):
        """
        Check if there is an instance with name

        Parameters:
         - name

        """
        self.send_exist_server(name)
        return self.recv_exist_server()

    def send_exist_server(self, name):
        self._oprot.writeMessageBegin('exist_server', TMessageType.CALL, self._seqid)
        args = exist_server_args()
        args.name = name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_exist_server(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = exist_server_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "exist_server failed: unknown result")

    def create_and_deploy_playbook(self, public_key, playbooks_information, openstack_id):
        """
        Create and deploy an anaconda ansible playbook

        Parameters:
         - public_key
         - playbooks_information
         - openstack_id

        """
        self.send_create_and_deploy_playbook(public_key, playbooks_information, openstack_id)
        return self.recv_create_and_deploy_playbook()

    def send_create_and_deploy_playbook(self, public_key, playbooks_information, openstack_id):
        self._oprot.writeMessageBegin('create_and_deploy_playbook', TMessageType.CALL, self._seqid)
        args = create_and_deploy_playbook_args()
        args.public_key = public_key
        args.playbooks_information = playbooks_information
        args.openstack_id = openstack_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_and_deploy_playbook(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_and_deploy_playbook_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "create_and_deploy_playbook failed: unknown result")

    def get_playbook_logs(self, openstack_id):
        """
        Get the logs from a playbook run

        Parameters:
         - openstack_id

        """
        self.send_get_playbook_logs(openstack_id)
        return self.recv_get_playbook_logs()

    def send_get_playbook_logs(self, openstack_id):
        self._oprot.writeMessageBegin('get_playbook_logs', TMessageType.CALL, self._seqid)
        args = get_playbook_logs_args()
        args.openstack_id = openstack_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_playbook_logs(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_playbook_logs_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_playbook_logs failed: unknown result")

    def has_forc(self):
        """
        Get boolean if client has backend url configured

        """
        self.send_has_forc()
        return self.recv_has_forc()

    def send_has_forc(self):
        self._oprot.writeMessageBegin('has_forc', TMessageType.CALL, self._seqid)
        args = has_forc_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_has_forc(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = has_forc_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "has_forc failed: unknown result")

    def get_forc_url(self):
        self.send_get_forc_url()
        return self.recv_get_forc_url()

    def send_get_forc_url(self):
        self._oprot.writeMessageBegin('get_forc_url', TMessageType.CALL, self._seqid)
        args = get_forc_url_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_forc_url(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_forc_url_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_forc_url failed: unknown result")

    def create_backend(self, elixir_id, user_key_url, template, upstream_url):
        """
        Create a backend

        Parameters:
         - elixir_id
         - user_key_url
         - template
         - upstream_url

        """
        self.send_create_backend(elixir_id, user_key_url, template, upstream_url)
        return self.recv_create_backend()

    def send_create_backend(self, elixir_id, user_key_url, template, upstream_url):
        self._oprot.writeMessageBegin('create_backend', TMessageType.CALL, self._seqid)
        args = create_backend_args()
        args.elixir_id = elixir_id
        args.user_key_url = user_key_url
        args.template = template
        args.upstream_url = upstream_url
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_backend(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_backend_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "create_backend failed: unknown result")

    def get_backends(self):
        """
        Get all backends

        """
        self.send_get_backends()
        return self.recv_get_backends()

    def send_get_backends(self):
        self._oprot.writeMessageBegin('get_backends', TMessageType.CALL, self._seqid)
        args = get_backends_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_backends(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_backends_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_backends failed: unknown result")

    def get_backends_by_owner(self, elixir_id):
        """
        Get all backends by owner

        Parameters:
         - elixir_id

        """
        self.send_get_backends_by_owner(elixir_id)
        return self.recv_get_backends_by_owner()

    def send_get_backends_by_owner(self, elixir_id):
        self._oprot.writeMessageBegin('get_backends_by_owner', TMessageType.CALL, self._seqid)
        args = get_backends_by_owner_args()
        args.elixir_id = elixir_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_backends_by_owner(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_backends_by_owner_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_backends_by_owner failed: unknown result")

    def get_backends_by_template(self, template):
        """
        Get all backends by template

        Parameters:
         - template

        """
        self.send_get_backends_by_template(template)
        return self.recv_get_backends_by_template()

    def send_get_backends_by_template(self, template):
        self._oprot.writeMessageBegin('get_backends_by_template', TMessageType.CALL, self._seqid)
        args = get_backends_by_template_args()
        args.template = template
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_backends_by_template(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_backends_by_template_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_backends_by_template failed: unknown result")

    def get_backend_by_id(self, id):
        """
        Get a backend by id

        Parameters:
         - id

        """
        self.send_get_backend_by_id(id)
        return self.recv_get_backend_by_id()

    def send_get_backend_by_id(self, id):
        self._oprot.writeMessageBegin('get_backend_by_id', TMessageType.CALL, self._seqid)
        args = get_backend_by_id_args()
        args.id = id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_backend_by_id(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_backend_by_id_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_backend_by_id failed: unknown result")

    def delete_backend(self, id):
        """
        Delete a backend

        Parameters:
         - id

        """
        self.send_delete_backend(id)
        return self.recv_delete_backend()

    def send_delete_backend(self, id):
        self._oprot.writeMessageBegin('delete_backend', TMessageType.CALL, self._seqid)
        args = delete_backend_args()
        args.id = id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_delete_backend(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = delete_backend_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "delete_backend failed: unknown result")

    def add_user_to_backend(self, backend_id, owner_id, user_id):
        """
        Add a user to a backend

        Parameters:
         - backend_id
         - owner_id
         - user_id

        """
        self.send_add_user_to_backend(backend_id, owner_id, user_id)
        return self.recv_add_user_to_backend()

    def send_add_user_to_backend(self, backend_id, owner_id, user_id):
        self._oprot.writeMessageBegin('add_user_to_backend', TMessageType.CALL, self._seqid)
        args = add_user_to_backend_args()
        args.backend_id = backend_id
        args.owner_id = owner_id
        args.user_id = user_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_user_to_backend(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_user_to_backend_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "add_user_to_backend failed: unknown result")

    def get_users_from_backend(self, backend_id):
        """
        Get users from a backend

        Parameters:
         - backend_id

        """
        self.send_get_users_from_backend(backend_id)
        return self.recv_get_users_from_backend()

    def send_get_users_from_backend(self, backend_id):
        self._oprot.writeMessageBegin('get_users_from_backend', TMessageType.CALL, self._seqid)
        args = get_users_from_backend_args()
        args.backend_id = backend_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_users_from_backend(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_users_from_backend_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_users_from_backend failed: unknown result")

    def delete_user_from_backend(self, backend_id, owner_id, user_id):
        """
        Delete user from a backend

        Parameters:
         - backend_id
         - owner_id
         - user_id

        """
        self.send_delete_user_from_backend(backend_id, owner_id, user_id)
        return self.recv_delete_user_from_backend()

    def send_delete_user_from_backend(self, backend_id, owner_id, user_id):
        self._oprot.writeMessageBegin('delete_user_from_backend', TMessageType.CALL, self._seqid)
        args = delete_user_from_backend_args()
        args.backend_id = backend_id
        args.owner_id = owner_id
        args.user_id = user_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_delete_user_from_backend(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = delete_user_from_backend_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "delete_user_from_backend failed: unknown result")

    def get_templates(self):
        self.send_get_templates()
        return self.recv_get_templates()

    def send_get_templates(self):
        self._oprot.writeMessageBegin('get_templates', TMessageType.CALL, self._seqid)
        args = get_templates_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_templates(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_templates_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_templates failed: unknown result")

    def get_allowed_templates(self):
        self.send_get_allowed_templates()
        return self.recv_get_allowed_templates()

    def send_get_allowed_templates(self):
        self._oprot.writeMessageBegin('get_allowed_templates', TMessageType.CALL, self._seqid)
        args = get_allowed_templates_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_allowed_templates(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_allowed_templates_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_allowed_templates failed: unknown result")

    def get_templates_by_template(self, template_name):
        """
        Parameters:
         - template_name

        """
        self.send_get_templates_by_template(template_name)
        return self.recv_get_templates_by_template()

    def send_get_templates_by_template(self, template_name):
        self._oprot.writeMessageBegin('get_templates_by_template', TMessageType.CALL, self._seqid)
        args = get_templates_by_template_args()
        args.template_name = template_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_templates_by_template(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_templates_by_template_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_templates_by_template failed: unknown result")

    def check_template(self, template_name, template_version):
        """
        Parameters:
         - template_name
         - template_version

        """
        self.send_check_template(template_name, template_version)
        return self.recv_check_template()

    def send_check_template(self, template_name, template_version):
        self._oprot.writeMessageBegin('check_template', TMessageType.CALL, self._seqid)
        args = check_template_args()
        args.template_name = template_name
        args.template_version = template_version
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_check_template(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = check_template_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "check_template failed: unknown result")

    def add_udp_security_group(self, server_id):
        """
        Adds a security group to a server

        Parameters:
         - server_id: OpenStack id of the server

        """
        self.send_add_udp_security_group(server_id)
        return self.recv_add_udp_security_group()

    def send_add_udp_security_group(self, server_id):
        self._oprot.writeMessageBegin('add_udp_security_group', TMessageType.CALL, self._seqid)
        args = add_udp_security_group_args()
        args.server_id = server_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_udp_security_group(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_udp_security_group_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.r is not None:
            raise result.r
        if result.s is not None:
            raise result.s
        raise TApplicationException(TApplicationException.MISSING_RESULT, "add_udp_security_group failed: unknown result")

    def get_servers(self):
        """
        Get all servers.
        Returns: List of server instances.

        """
        self.send_get_servers()
        return self.recv_get_servers()

    def send_get_servers(self):
        self._oprot.writeMessageBegin('get_servers', TMessageType.CALL, self._seqid)
        args = get_servers_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_servers(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_servers_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_servers failed: unknown result")

    def get_servers_by_ids(self, server_ids):
        """
        * Get list of servers by ids
           *

        Parameters:
         - server_ids

        """
        self.send_get_servers_by_ids(server_ids)
        return self.recv_get_servers_by_ids()

    def send_get_servers_by_ids(self, server_ids):
        self._oprot.writeMessageBegin('get_servers_by_ids', TMessageType.CALL, self._seqid)
        args = get_servers_by_ids_args()
        args.server_ids = server_ids
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_servers_by_ids(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_servers_by_ids_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_servers_by_ids failed: unknown result")

    def check_server_task_state(self, openstack_id):
        """
        Parameters:
         - openstack_id

        """
        self.send_check_server_task_state(openstack_id)
        return self.recv_check_server_task_state()

    def send_check_server_task_state(self, openstack_id):
        self._oprot.writeMessageBegin('check_server_task_state', TMessageType.CALL, self._seqid)
        args = check_server_task_state_args()
        args.openstack_id = openstack_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_check_server_task_state(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = check_server_task_state_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "check_server_task_state failed: unknown result")

    def get_servers_by_bibigrid_id(self, bibigrid_id):
        """
        * Get servers by bibigrid cluster id.
           *

        Parameters:
         - bibigrid_id

        """
        self.send_get_servers_by_bibigrid_id(bibigrid_id)
        return self.recv_get_servers_by_bibigrid_id()

    def send_get_servers_by_bibigrid_id(self, bibigrid_id):
        self._oprot.writeMessageBegin('get_servers_by_bibigrid_id', TMessageType.CALL, self._seqid)
        args = get_servers_by_bibigrid_id_args()
        args.bibigrid_id = bibigrid_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_servers_by_bibigrid_id(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_servers_by_bibigrid_id_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_servers_by_bibigrid_id failed: unknown result")

    def scale_up_cluster(self, cluster_id, image, flavor, count, names, start_idx, batch_idx):
        """
        Parameters:
         - cluster_id
         - image
         - flavor
         - count
         - names
         - start_idx
         - batch_idx

        """
        self.send_scale_up_cluster(cluster_id, image, flavor, count, names, start_idx, batch_idx)
        return self.recv_scale_up_cluster()

    def send_scale_up_cluster(self, cluster_id, image, flavor, count, names, start_idx, batch_idx):
        self._oprot.writeMessageBegin('scale_up_cluster', TMessageType.CALL, self._seqid)
        args = scale_up_cluster_args()
        args.cluster_id = cluster_id
        args.image = image
        args.flavor = flavor
        args.count = count
        args.names = names
        args.start_idx = start_idx
        args.batch_idx = batch_idx
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_scale_up_cluster(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = scale_up_cluster_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "scale_up_cluster failed: unknown result")

    def add_cluster_machine(self, cluster_id, cluster_user, cluster_group_id, image, flavor, name, key_name, batch_idx, worker_idx):
        """
        Parameters:
         - cluster_id
         - cluster_user
         - cluster_group_id
         - image
         - flavor
         - name
         - key_name
         - batch_idx
         - worker_idx

        """
        self.send_add_cluster_machine(cluster_id, cluster_user, cluster_group_id, image, flavor, name, key_name, batch_idx, worker_idx)
        return self.recv_add_cluster_machine()

    def send_add_cluster_machine(self, cluster_id, cluster_user, cluster_group_id, image, flavor, name, key_name, batch_idx, worker_idx):
        self._oprot.writeMessageBegin('add_cluster_machine', TMessageType.CALL, self._seqid)
        args = add_cluster_machine_args()
        args.cluster_id = cluster_id
        args.cluster_user = cluster_user
        args.cluster_group_id = cluster_group_id
        args.image = image
        args.flavor = flavor
        args.name = name
        args.key_name = key_name
        args.batch_idx = batch_idx
        args.worker_idx = worker_idx
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_cluster_machine(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_cluster_machine_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "add_cluster_machine failed: unknown result")

    def get_cluster_info(self, cluster_id):
        """
        Parameters:
         - cluster_id

        """
        self.send_get_cluster_info(cluster_id)
        return self.recv_get_cluster_info()

    def send_get_cluster_info(self, cluster_id):
        self._oprot.writeMessageBegin('get_cluster_info', TMessageType.CALL, self._seqid)
        args = get_cluster_info_args()
        args.cluster_id = cluster_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_cluster_info(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_cluster_info_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_cluster_info failed: unknown result")

    def get_cluster_status(self, cluster_id):
        """
        Parameters:
         - cluster_id

        """
        self.send_get_cluster_status(cluster_id)
        return self.recv_get_cluster_status()

    def send_get_cluster_status(self, cluster_id):
        self._oprot.writeMessageBegin('get_cluster_status', TMessageType.CALL, self._seqid)
        args = get_cluster_status_args()
        args.cluster_id = cluster_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_cluster_status(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_cluster_status_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_cluster_status failed: unknown result")

    def get_server(self, openstack_id):
        """
        Get a Server.
        Returns: A server instance.

        Parameters:
         - openstack_id: Id of the server.

        """
        self.send_get_server(openstack_id)
        return self.recv_get_server()

    def send_get_server(self, openstack_id):
        self._oprot.writeMessageBegin('get_server', TMessageType.CALL, self._seqid)
        args = get_server_args()
        args.openstack_id = openstack_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_server(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_server_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_server failed: unknown result")

    def stop_server(self, openstack_id):
        """
        Stop a Server.
        Returns: True if stopped, False if not.

        Parameters:
         - openstack_id: Id of the server.

        """
        self.send_stop_server(openstack_id)
        return self.recv_stop_server()

    def send_stop_server(self, openstack_id):
        self._oprot.writeMessageBegin('stop_server', TMessageType.CALL, self._seqid)
        args = stop_server_args()
        args.openstack_id = openstack_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_stop_server(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = stop_server_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        if result.c is not None:
            raise result.c
        raise TApplicationException(TApplicationException.MISSING_RESULT, "stop_server failed: unknown result")

    def create_snapshot(self, openstack_id, name, elixir_id, base_tags, description):
        """
        Create Snapshot.
        Returns: Id of new Snapshot


        Parameters:
         - openstack_id: Id of the server
         - name: Name of new Snapshot
         - elixir_id: Elixir-Id of the user who requested creation of Snapshot
         - base_tags: Tags with which the servers image is also tagged ( for connection information at the webapp)
         - description: Description of the new snapshot

        """
        self.send_create_snapshot(openstack_id, name, elixir_id, base_tags, description)
        return self.recv_create_snapshot()

    def send_create_snapshot(self, openstack_id, name, elixir_id, base_tags, description):
        self._oprot.writeMessageBegin('create_snapshot', TMessageType.CALL, self._seqid)
        args = create_snapshot_args()
        args.openstack_id = openstack_id
        args.name = name
        args.elixir_id = elixir_id
        args.base_tags = base_tags
        args.description = description
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_snapshot(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_snapshot_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        if result.c is not None:
            raise result.c
        raise TApplicationException(TApplicationException.MISSING_RESULT, "create_snapshot failed: unknown result")

    def get_limits(self):
        """
        Get Limits of OpenStack Projekt from client.
        Returns: {'maxTotalVolumes': maxTotalVolumes, 'maxTotalVolumeGigabytes': maxTotalVolumeGigabytes,
                  'maxTotalInstances': maxTotalInstances, 'totalRamUsed': totalRamUsed,
                 'totalInstancesUsed': totalInstancesUsed}

        """
        self.send_get_limits()
        return self.recv_get_limits()

    def send_get_limits(self):
        self._oprot.writeMessageBegin('get_limits', TMessageType.CALL, self._seqid)
        args = get_limits_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_limits(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_limits_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_limits failed: unknown result")

    def start_cluster(self, public_key, master_instance, worker_instance, user):
        """
        Parameters:
         - public_key
         - master_instance
         - worker_instance
         - user

        """
        self.send_start_cluster(public_key, master_instance, worker_instance, user)
        return self.recv_start_cluster()

    def send_start_cluster(self, public_key, master_instance, worker_instance, user):
        self._oprot.writeMessageBegin('start_cluster', TMessageType.CALL, self._seqid)
        args = start_cluster_args()
        args.public_key = public_key
        args.master_instance = master_instance
        args.worker_instance = worker_instance
        args.user = user
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_start_cluster(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = start_cluster_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "start_cluster failed: unknown result")

    def terminate_cluster(self, cluster_id):
        """
        Parameters:
         - cluster_id

        """
        self.send_terminate_cluster(cluster_id)
        return self.recv_terminate_cluster()

    def send_terminate_cluster(self, cluster_id):
        self._oprot.writeMessageBegin('terminate_cluster', TMessageType.CALL, self._seqid)
        args = terminate_cluster_args()
        args.cluster_id = cluster_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_terminate_cluster(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = terminate_cluster_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "terminate_cluster failed: unknown result")

    def delete_image(self, image_id):
        """
        Delete Image.
        Return: True if deleted, False if not

        Parameters:
         - image_id: Id of image

        """
        self.send_delete_image(image_id)
        return self.recv_delete_image()

    def send_delete_image(self, image_id):
        self._oprot.writeMessageBegin('delete_image', TMessageType.CALL, self._seqid)
        args = delete_image_args()
        args.image_id = image_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_delete_image(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = delete_image_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "delete_image failed: unknown result")

    def delete_volume_attachment(self, volume_id, server_id):
        """
        Delete volume attachment
        Return: True if deleted, False if not

        Parameters:
         - volume_id: Id of the attached volume
         - server_id: Id of the server where the volume is attached

        """
        self.send_delete_volume_attachment(volume_id, server_id)
        return self.recv_delete_volume_attachment()

    def send_delete_volume_attachment(self, volume_id, server_id):
        self._oprot.writeMessageBegin('delete_volume_attachment', TMessageType.CALL, self._seqid)
        args = delete_volume_attachment_args()
        args.volume_id = volume_id
        args.server_id = server_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_delete_volume_attachment(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = delete_volume_attachment_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        if result.c is not None:
            raise result.c
        raise TApplicationException(TApplicationException.MISSING_RESULT, "delete_volume_attachment failed: unknown result")

    def delete_volume(self, volume_id):
        """
        Delete volume.
        Returns:  True if deleted, False if not

        Parameters:
         - volume_id

        """
        self.send_delete_volume(volume_id)
        return self.recv_delete_volume()

    def send_delete_volume(self, volume_id):
        self._oprot.writeMessageBegin('delete_volume', TMessageType.CALL, self._seqid)
        args = delete_volume_args()
        args.volume_id = volume_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_delete_volume(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = delete_volume_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.c is not None:
            raise result.c
        raise TApplicationException(TApplicationException.MISSING_RESULT, "delete_volume failed: unknown result")

    def attach_volume_to_server(self, openstack_id, volume_id):
        """
        Attach volume to server.
        Returns:  True if attached, False if not

        Parameters:
         - openstack_id: Id of server
         - volume_id: Id of volume

        """
        self.send_attach_volume_to_server(openstack_id, volume_id)
        return self.recv_attach_volume_to_server()

    def send_attach_volume_to_server(self, openstack_id, volume_id):
        self._oprot.writeMessageBegin('attach_volume_to_server', TMessageType.CALL, self._seqid)
        args = attach_volume_to_server_args()
        args.openstack_id = openstack_id
        args.volume_id = volume_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_attach_volume_to_server(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = attach_volume_to_server_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        if result.c is not None:
            raise result.c
        raise TApplicationException(TApplicationException.MISSING_RESULT, "attach_volume_to_server failed: unknown result")

    def check_server_status(self, openstack_id):
        """
        Check status of server.
        Returns: server instance

        Parameters:
         - openstack_id: Id of the server

        """
        self.send_check_server_status(openstack_id)
        return self.recv_check_server_status()

    def send_check_server_status(self, openstack_id):
        self._oprot.writeMessageBegin('check_server_status', TMessageType.CALL, self._seqid)
        args = check_server_status_args()
        args.openstack_id = openstack_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_check_server_status(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = check_server_status_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        if result.r is not None:
            raise result.r
        raise TApplicationException(TApplicationException.MISSING_RESULT, "check_server_status failed: unknown result")

    def resume_server(self, openstack_id):
        """
        Resume Server.
        Returns: True if resumed False if not

        Parameters:
         - openstack_id: Id of the server

        """
        self.send_resume_server(openstack_id)
        return self.recv_resume_server()

    def send_resume_server(self, openstack_id):
        self._oprot.writeMessageBegin('resume_server', TMessageType.CALL, self._seqid)
        args = resume_server_args()
        args.openstack_id = openstack_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_resume_server(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = resume_server_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        if result.c is not None:
            raise result.c
        raise TApplicationException(TApplicationException.MISSING_RESULT, "resume_server failed: unknown result")

    def create_volume(self, volume_name, volume_storage, metadata):
        """
        Create volume.
        Returns: Id of new volume

        Parameters:
         - volume_name: Name of volume
         - volume_storage: Diskspace in GB for new volume
         - metadata: Metadata for the new volume

        """
        self.send_create_volume(volume_name, volume_storage, metadata)
        return self.recv_create_volume()

    def send_create_volume(self, volume_name, volume_storage, metadata):
        self._oprot.writeMessageBegin('create_volume', TMessageType.CALL, self._seqid)
        args = create_volume_args()
        args.volume_name = volume_name
        args.volume_storage = volume_storage
        args.metadata = metadata
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_volume(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_volume_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.r is not None:
            raise result.r
        raise TApplicationException(TApplicationException.MISSING_RESULT, "create_volume failed: unknown result")

    def reboot_server(self, openstack_id, reboot_type):
        """
        Reboot server.
        Returns: True if rebooted False if not

        Parameters:
         - openstack_id: Id of the server
         - reboot_type: HARD or SOFT

        """
        self.send_reboot_server(openstack_id, reboot_type)
        return self.recv_reboot_server()

    def send_reboot_server(self, openstack_id, reboot_type):
        self._oprot.writeMessageBegin('reboot_server', TMessageType.CALL, self._seqid)
        args = reboot_server_args()
        args.openstack_id = openstack_id
        args.reboot_type = reboot_type
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_reboot_server(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = reboot_server_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        if result.c is not None:
            raise result.c
        raise TApplicationException(TApplicationException.MISSING_RESULT, "reboot_server failed: unknown result")


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["check_version"] = Processor.process_check_version
        self._processMap["get_client_version"] = Processor.process_get_client_version
        self._processMap["get_gateway_ip"] = Processor.process_get_gateway_ip
        self._processMap["get_calculation_values"] = Processor.process_get_calculation_values
        self._processMap["import_keypair"] = Processor.process_import_keypair
        self._processMap["get_vm_ports"] = Processor.process_get_vm_ports
        self._processMap["get_flavors"] = Processor.process_get_flavors
        self._processMap["get_images"] = Processor.process_get_images
        self._processMap["get_public_images"] = Processor.process_get_public_images
        self._processMap["get_private_images"] = Processor.process_get_private_images
        self._processMap["get_image"] = Processor.process_get_image
        self._processMap["get_images_by_filter"] = Processor.process_get_images_by_filter
        self._processMap["get_volume"] = Processor.process_get_volume
        self._processMap["get_volumes_by_ids"] = Processor.process_get_volumes_by_ids
        self._processMap["resize_volume"] = Processor.process_resize_volume
        self._processMap["delete_server"] = Processor.process_delete_server
        self._processMap["start_server"] = Processor.process_start_server
        self._processMap["bibigrid_available"] = Processor.process_bibigrid_available
        self._processMap["detach_ip_from_server"] = Processor.process_detach_ip_from_server
        self._processMap["start_server_with_custom_key"] = Processor.process_start_server_with_custom_key
        self._processMap["exist_server"] = Processor.process_exist_server
        self._processMap["create_and_deploy_playbook"] = Processor.process_create_and_deploy_playbook
        self._processMap["get_playbook_logs"] = Processor.process_get_playbook_logs
        self._processMap["has_forc"] = Processor.process_has_forc
        self._processMap["get_forc_url"] = Processor.process_get_forc_url
        self._processMap["create_backend"] = Processor.process_create_backend
        self._processMap["get_backends"] = Processor.process_get_backends
        self._processMap["get_backends_by_owner"] = Processor.process_get_backends_by_owner
        self._processMap["get_backends_by_template"] = Processor.process_get_backends_by_template
        self._processMap["get_backend_by_id"] = Processor.process_get_backend_by_id
        self._processMap["delete_backend"] = Processor.process_delete_backend
        self._processMap["add_user_to_backend"] = Processor.process_add_user_to_backend
        self._processMap["get_users_from_backend"] = Processor.process_get_users_from_backend
        self._processMap["delete_user_from_backend"] = Processor.process_delete_user_from_backend
        self._processMap["get_templates"] = Processor.process_get_templates
        self._processMap["get_allowed_templates"] = Processor.process_get_allowed_templates
        self._processMap["get_templates_by_template"] = Processor.process_get_templates_by_template
        self._processMap["check_template"] = Processor.process_check_template
        self._processMap["add_udp_security_group"] = Processor.process_add_udp_security_group
        self._processMap["get_servers"] = Processor.process_get_servers
        self._processMap["get_servers_by_ids"] = Processor.process_get_servers_by_ids
        self._processMap["check_server_task_state"] = Processor.process_check_server_task_state
        self._processMap["get_servers_by_bibigrid_id"] = Processor.process_get_servers_by_bibigrid_id
        self._processMap["scale_up_cluster"] = Processor.process_scale_up_cluster
        self._processMap["add_cluster_machine"] = Processor.process_add_cluster_machine
        self._processMap["get_cluster_info"] = Processor.process_get_cluster_info
        self._processMap["get_cluster_status"] = Processor.process_get_cluster_status
        self._processMap["get_server"] = Processor.process_get_server
        self._processMap["stop_server"] = Processor.process_stop_server
        self._processMap["create_snapshot"] = Processor.process_create_snapshot
        self._processMap["get_limits"] = Processor.process_get_limits
        self._processMap["start_cluster"] = Processor.process_start_cluster
        self._processMap["terminate_cluster"] = Processor.process_terminate_cluster
        self._processMap["delete_image"] = Processor.process_delete_image
        self._processMap["delete_volume_attachment"] = Processor.process_delete_volume_attachment
        self._processMap["delete_volume"] = Processor.process_delete_volume
        self._processMap["attach_volume_to_server"] = Processor.process_attach_volume_to_server
        self._processMap["check_server_status"] = Processor.process_check_server_status
        self._processMap["resume_server"] = Processor.process_resume_server
        self._processMap["create_volume"] = Processor.process_create_volume
        self._processMap["reboot_server"] = Processor.process_reboot_server
        self._on_message_begin = None

    def on_message_begin(self, func):
        self._on_message_begin = func

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if self._on_message_begin:
            self._on_message_begin(name, type, seqid)
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_check_version(self, seqid, iprot, oprot):
        args = check_version_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = check_version_result()
        try:
            result.success = self._handler.check_version(args.version)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("check_version", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_client_version(self, seqid, iprot, oprot):
        args = get_client_version_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_client_version_result()
        try:
            result.success = self._handler.get_client_version()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_client_version", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_gateway_ip(self, seqid, iprot, oprot):
        args = get_gateway_ip_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_gateway_ip_result()
        try:
            result.success = self._handler.get_gateway_ip()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_gateway_ip", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_calculation_values(self, seqid, iprot, oprot):
        args = get_calculation_values_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_calculation_values_result()
        try:
            result.success = self._handler.get_calculation_values()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_calculation_values", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_import_keypair(self, seqid, iprot, oprot):
        args = import_keypair_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = import_keypair_result()
        try:
            result.success = self._handler.import_keypair(args.keyname, args.public_key)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("import_keypair", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_vm_ports(self, seqid, iprot, oprot):
        args = get_vm_ports_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_vm_ports_result()
        try:
            result.success = self._handler.get_vm_ports(args.openstack_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_vm_ports", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_flavors(self, seqid, iprot, oprot):
        args = get_flavors_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_flavors_result()
        try:
            result.success = self._handler.get_flavors()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_flavors", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_images(self, seqid, iprot, oprot):
        args = get_images_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_images_result()
        try:
            result.success = self._handler.get_images()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_images", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_public_images(self, seqid, iprot, oprot):
        args = get_public_images_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_public_images_result()
        try:
            result.success = self._handler.get_public_images()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_public_images", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_private_images(self, seqid, iprot, oprot):
        args = get_private_images_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_private_images_result()
        try:
            result.success = self._handler.get_private_images()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_private_images", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_image(self, seqid, iprot, oprot):
        args = get_image_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_image_result()
        try:
            result.success = self._handler.get_image(args.openstack_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_image", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_images_by_filter(self, seqid, iprot, oprot):
        args = get_images_by_filter_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_images_by_filter_result()
        try:
            result.success = self._handler.get_images_by_filter(args.filter_json)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_images_by_filter", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_volume(self, seqid, iprot, oprot):
        args = get_volume_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_volume_result()
        try:
            result.success = self._handler.get_volume(args.volume_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_volume", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_volumes_by_ids(self, seqid, iprot, oprot):
        args = get_volumes_by_ids_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_volumes_by_ids_result()
        try:
            result.success = self._handler.get_volumes_by_ids(args.volume_ids)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_volumes_by_ids", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_resize_volume(self, seqid, iprot, oprot):
        args = resize_volume_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = resize_volume_result()
        try:
            result.success = self._handler.resize_volume(args.volume_id, args.size)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("resize_volume", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_delete_server(self, seqid, iprot, oprot):
        args = delete_server_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = delete_server_result()
        try:
            result.success = self._handler.delete_server(args.openstack_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except serverNotFoundException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except conflictException as c:
            msg_type = TMessageType.REPLY
            result.c = c
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("delete_server", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_start_server(self, seqid, iprot, oprot):
        args = start_server_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = start_server_result()
        try:
            result.success = self._handler.start_server(args.flavor, args.image, args.public_key, args.servername, args.metadata, args.research_environment, args.volume_ids_path_new, args.volume_ids_path_attach, args.additional_keys)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except nameException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except ressourceException as r:
            msg_type = TMessageType.REPLY
            result.r = r
        except serverNotFoundException as s:
            msg_type = TMessageType.REPLY
            result.s = s
        except networkNotFoundException as n:
            msg_type = TMessageType.REPLY
            result.n = n
        except imageNotFoundException as i:
            msg_type = TMessageType.REPLY
            result.i = i
        except flavorNotFoundException as f:
            msg_type = TMessageType.REPLY
            result.f = f
        except otherException as o:
            msg_type = TMessageType.REPLY
            result.o = o
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("start_server", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_bibigrid_available(self, seqid, iprot, oprot):
        args = bibigrid_available_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = bibigrid_available_result()
        try:
            result.success = self._handler.bibigrid_available()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("bibigrid_available", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_detach_ip_from_server(self, seqid, iprot, oprot):
        args = detach_ip_from_server_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = detach_ip_from_server_result()
        try:
            result.success = self._handler.detach_ip_from_server(args.server_id, args.floating_ip)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("detach_ip_from_server", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_start_server_with_custom_key(self, seqid, iprot, oprot):
        args = start_server_with_custom_key_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = start_server_with_custom_key_result()
        try:
            result.success = self._handler.start_server_with_custom_key(args.flavor, args.image, args.servername, args.metadata, args.research_environment, args.volume_ids_path_new, args.volume_ids_path_attach)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except nameException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except ressourceException as r:
            msg_type = TMessageType.REPLY
            result.r = r
        except serverNotFoundException as s:
            msg_type = TMessageType.REPLY
            result.s = s
        except networkNotFoundException as n:
            msg_type = TMessageType.REPLY
            result.n = n
        except imageNotFoundException as i:
            msg_type = TMessageType.REPLY
            result.i = i
        except flavorNotFoundException as f:
            msg_type = TMessageType.REPLY
            result.f = f
        except otherException as o:
            msg_type = TMessageType.REPLY
            result.o = o
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("start_server_with_custom_key", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_exist_server(self, seqid, iprot, oprot):
        args = exist_server_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = exist_server_result()
        try:
            result.success = self._handler.exist_server(args.name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("exist_server", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_and_deploy_playbook(self, seqid, iprot, oprot):
        args = create_and_deploy_playbook_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_and_deploy_playbook_result()
        try:
            result.success = self._handler.create_and_deploy_playbook(args.public_key, args.playbooks_information, args.openstack_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("create_and_deploy_playbook", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_playbook_logs(self, seqid, iprot, oprot):
        args = get_playbook_logs_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_playbook_logs_result()
        try:
            result.success = self._handler.get_playbook_logs(args.openstack_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_playbook_logs", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_has_forc(self, seqid, iprot, oprot):
        args = has_forc_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = has_forc_result()
        try:
            result.success = self._handler.has_forc()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("has_forc", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_forc_url(self, seqid, iprot, oprot):
        args = get_forc_url_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_forc_url_result()
        try:
            result.success = self._handler.get_forc_url()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_forc_url", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_backend(self, seqid, iprot, oprot):
        args = create_backend_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_backend_result()
        try:
            result.success = self._handler.create_backend(args.elixir_id, args.user_key_url, args.template, args.upstream_url)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("create_backend", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_backends(self, seqid, iprot, oprot):
        args = get_backends_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_backends_result()
        try:
            result.success = self._handler.get_backends()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_backends", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_backends_by_owner(self, seqid, iprot, oprot):
        args = get_backends_by_owner_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_backends_by_owner_result()
        try:
            result.success = self._handler.get_backends_by_owner(args.elixir_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_backends_by_owner", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_backends_by_template(self, seqid, iprot, oprot):
        args = get_backends_by_template_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_backends_by_template_result()
        try:
            result.success = self._handler.get_backends_by_template(args.template)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_backends_by_template", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_backend_by_id(self, seqid, iprot, oprot):
        args = get_backend_by_id_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_backend_by_id_result()
        try:
            result.success = self._handler.get_backend_by_id(args.id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_backend_by_id", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_delete_backend(self, seqid, iprot, oprot):
        args = delete_backend_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = delete_backend_result()
        try:
            result.success = self._handler.delete_backend(args.id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("delete_backend", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_user_to_backend(self, seqid, iprot, oprot):
        args = add_user_to_backend_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_user_to_backend_result()
        try:
            result.success = self._handler.add_user_to_backend(args.backend_id, args.owner_id, args.user_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("add_user_to_backend", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_users_from_backend(self, seqid, iprot, oprot):
        args = get_users_from_backend_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_users_from_backend_result()
        try:
            result.success = self._handler.get_users_from_backend(args.backend_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_users_from_backend", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_delete_user_from_backend(self, seqid, iprot, oprot):
        args = delete_user_from_backend_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = delete_user_from_backend_result()
        try:
            result.success = self._handler.delete_user_from_backend(args.backend_id, args.owner_id, args.user_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("delete_user_from_backend", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_templates(self, seqid, iprot, oprot):
        args = get_templates_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_templates_result()
        try:
            result.success = self._handler.get_templates()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_templates", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_allowed_templates(self, seqid, iprot, oprot):
        args = get_allowed_templates_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_allowed_templates_result()
        try:
            result.success = self._handler.get_allowed_templates()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_allowed_templates", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_templates_by_template(self, seqid, iprot, oprot):
        args = get_templates_by_template_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_templates_by_template_result()
        try:
            result.success = self._handler.get_templates_by_template(args.template_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_templates_by_template", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_check_template(self, seqid, iprot, oprot):
        args = check_template_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = check_template_result()
        try:
            result.success = self._handler.check_template(args.template_name, args.template_version)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("check_template", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_udp_security_group(self, seqid, iprot, oprot):
        args = add_udp_security_group_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_udp_security_group_result()
        try:
            result.success = self._handler.add_udp_security_group(args.server_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ressourceException as r:
            msg_type = TMessageType.REPLY
            result.r = r
        except serverNotFoundException as s:
            msg_type = TMessageType.REPLY
            result.s = s
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("add_udp_security_group", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_servers(self, seqid, iprot, oprot):
        args = get_servers_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_servers_result()
        try:
            result.success = self._handler.get_servers()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_servers", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_servers_by_ids(self, seqid, iprot, oprot):
        args = get_servers_by_ids_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_servers_by_ids_result()
        try:
            result.success = self._handler.get_servers_by_ids(args.server_ids)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_servers_by_ids", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_check_server_task_state(self, seqid, iprot, oprot):
        args = check_server_task_state_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = check_server_task_state_result()
        try:
            result.success = self._handler.check_server_task_state(args.openstack_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("check_server_task_state", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_servers_by_bibigrid_id(self, seqid, iprot, oprot):
        args = get_servers_by_bibigrid_id_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_servers_by_bibigrid_id_result()
        try:
            result.success = self._handler.get_servers_by_bibigrid_id(args.bibigrid_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_servers_by_bibigrid_id", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_scale_up_cluster(self, seqid, iprot, oprot):
        args = scale_up_cluster_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = scale_up_cluster_result()
        try:
            result.success = self._handler.scale_up_cluster(args.cluster_id, args.image, args.flavor, args.count, args.names, args.start_idx, args.batch_idx)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("scale_up_cluster", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_cluster_machine(self, seqid, iprot, oprot):
        args = add_cluster_machine_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_cluster_machine_result()
        try:
            result.success = self._handler.add_cluster_machine(args.cluster_id, args.cluster_user, args.cluster_group_id, args.image, args.flavor, args.name, args.key_name, args.batch_idx, args.worker_idx)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("add_cluster_machine", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_cluster_info(self, seqid, iprot, oprot):
        args = get_cluster_info_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_cluster_info_result()
        try:
            result.success = self._handler.get_cluster_info(args.cluster_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_cluster_info", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_cluster_status(self, seqid, iprot, oprot):
        args = get_cluster_status_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_cluster_status_result()
        try:
            result.success = self._handler.get_cluster_status(args.cluster_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_cluster_status", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_server(self, seqid, iprot, oprot):
        args = get_server_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_server_result()
        try:
            result.success = self._handler.get_server(args.openstack_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except serverNotFoundException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_server", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_stop_server(self, seqid, iprot, oprot):
        args = stop_server_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = stop_server_result()
        try:
            result.success = self._handler.stop_server(args.openstack_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except serverNotFoundException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except conflictException as c:
            msg_type = TMessageType.REPLY
            result.c = c
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("stop_server", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_snapshot(self, seqid, iprot, oprot):
        args = create_snapshot_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_snapshot_result()
        try:
            result.success = self._handler.create_snapshot(args.openstack_id, args.name, args.elixir_id, args.base_tags, args.description)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except serverNotFoundException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except conflictException as c:
            msg_type = TMessageType.REPLY
            result.c = c
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("create_snapshot", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_limits(self, seqid, iprot, oprot):
        args = get_limits_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_limits_result()
        try:
            result.success = self._handler.get_limits()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_limits", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_start_cluster(self, seqid, iprot, oprot):
        args = start_cluster_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = start_cluster_result()
        try:
            result.success = self._handler.start_cluster(args.public_key, args.master_instance, args.worker_instance, args.user)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("start_cluster", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_terminate_cluster(self, seqid, iprot, oprot):
        args = terminate_cluster_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = terminate_cluster_result()
        try:
            result.success = self._handler.terminate_cluster(args.cluster_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("terminate_cluster", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_delete_image(self, seqid, iprot, oprot):
        args = delete_image_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = delete_image_result()
        try:
            result.success = self._handler.delete_image(args.image_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except imageNotFoundException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("delete_image", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_delete_volume_attachment(self, seqid, iprot, oprot):
        args = delete_volume_attachment_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = delete_volume_attachment_result()
        try:
            result.success = self._handler.delete_volume_attachment(args.volume_id, args.server_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except serverNotFoundException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except conflictException as c:
            msg_type = TMessageType.REPLY
            result.c = c
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("delete_volume_attachment", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_delete_volume(self, seqid, iprot, oprot):
        args = delete_volume_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = delete_volume_result()
        try:
            result.success = self._handler.delete_volume(args.volume_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except conflictException as c:
            msg_type = TMessageType.REPLY
            result.c = c
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("delete_volume", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_attach_volume_to_server(self, seqid, iprot, oprot):
        args = attach_volume_to_server_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = attach_volume_to_server_result()
        try:
            result.success = self._handler.attach_volume_to_server(args.openstack_id, args.volume_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except serverNotFoundException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except conflictException as c:
            msg_type = TMessageType.REPLY
            result.c = c
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("attach_volume_to_server", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_check_server_status(self, seqid, iprot, oprot):
        args = check_server_status_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = check_server_status_result()
        try:
            result.success = self._handler.check_server_status(args.openstack_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except serverNotFoundException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except ressourceException as r:
            msg_type = TMessageType.REPLY
            result.r = r
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("check_server_status", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_resume_server(self, seqid, iprot, oprot):
        args = resume_server_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = resume_server_result()
        try:
            result.success = self._handler.resume_server(args.openstack_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except serverNotFoundException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except conflictException as c:
            msg_type = TMessageType.REPLY
            result.c = c
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("resume_server", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_volume(self, seqid, iprot, oprot):
        args = create_volume_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_volume_result()
        try:
            result.success = self._handler.create_volume(args.volume_name, args.volume_storage, args.metadata)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ressourceException as r:
            msg_type = TMessageType.REPLY
            result.r = r
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("create_volume", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_reboot_server(self, seqid, iprot, oprot):
        args = reboot_server_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = reboot_server_result()
        try:
            result.success = self._handler.reboot_server(args.openstack_id, args.reboot_type)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except serverNotFoundException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except conflictException as c:
            msg_type = TMessageType.REPLY
            result.c = c
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("reboot_server", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class check_version_args(object):
    """
    Attributes:
     - version

    """


    def __init__(self, version=None,):
        self.version = version

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.version = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('check_version_args')
        if self.version is not None:
            oprot.writeFieldBegin('version', TType.DOUBLE, 1)
            oprot.writeDouble(self.version)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(check_version_args)
check_version_args.thrift_spec = (
    None,  # 0
    (1, TType.DOUBLE, 'version', None, None, ),  # 1
)


class check_version_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('check_version_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(check_version_result)
check_version_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class get_client_version_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_client_version_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_client_version_args)
get_client_version_args.thrift_spec = (
)


class get_client_version_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_client_version_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_client_version_result)
get_client_version_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class get_gateway_ip_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_gateway_ip_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_gateway_ip_args)
get_gateway_ip_args.thrift_spec = (
)


class get_gateway_ip_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype24, _vtype25, _size23) = iprot.readMapBegin()
                    for _i27 in range(_size23):
                        _key28 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val29 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success[_key28] = _val29
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_gateway_ip_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for kiter30, viter31 in self.success.items():
                oprot.writeString(kiter30.encode('utf-8') if sys.version_info[0] == 2 else kiter30)
                oprot.writeString(viter31.encode('utf-8') if sys.version_info[0] == 2 else viter31)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_gateway_ip_result)
get_gateway_ip_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 0
)


class get_calculation_values_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_calculation_values_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_calculation_values_args)
get_calculation_values_args.thrift_spec = (
)


class get_calculation_values_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype33, _vtype34, _size32) = iprot.readMapBegin()
                    for _i36 in range(_size32):
                        _key37 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val38 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success[_key37] = _val38
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_calculation_values_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for kiter39, viter40 in self.success.items():
                oprot.writeString(kiter39.encode('utf-8') if sys.version_info[0] == 2 else kiter39)
                oprot.writeString(viter40.encode('utf-8') if sys.version_info[0] == 2 else viter40)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_calculation_values_result)
get_calculation_values_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 0
)


class import_keypair_args(object):
    """
    Attributes:
     - keyname: Name for the keypair
     - public_key: The public key

    """


    def __init__(self, keyname=None, public_key=None,):
        self.keyname = keyname
        self.public_key = public_key

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.keyname = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.public_key = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('import_keypair_args')
        if self.keyname is not None:
            oprot.writeFieldBegin('keyname', TType.STRING, 1)
            oprot.writeString(self.keyname.encode('utf-8') if sys.version_info[0] == 2 else self.keyname)
            oprot.writeFieldEnd()
        if self.public_key is not None:
            oprot.writeFieldBegin('public_key', TType.STRING, 2)
            oprot.writeString(self.public_key.encode('utf-8') if sys.version_info[0] == 2 else self.public_key)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(import_keypair_args)
import_keypair_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'keyname', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'public_key', 'UTF8', None, ),  # 2
)


class import_keypair_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('import_keypair_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(import_keypair_result)
import_keypair_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class get_vm_ports_args(object):
    """
    Attributes:
     - openstack_id: Id of server

    """


    def __init__(self, openstack_id=None,):
        self.openstack_id = openstack_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.openstack_id = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_vm_ports_args')
        if self.openstack_id is not None:
            oprot.writeFieldBegin('openstack_id', TType.STRING, 1)
            oprot.writeString(self.openstack_id.encode('utf-8') if sys.version_info[0] == 2 else self.openstack_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_vm_ports_args)
get_vm_ports_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'openstack_id', 'UTF8', None, ),  # 1
)


class get_vm_ports_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype42, _vtype43, _size41) = iprot.readMapBegin()
                    for _i45 in range(_size41):
                        _key46 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val47 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success[_key46] = _val47
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_vm_ports_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for kiter48, viter49 in self.success.items():
                oprot.writeString(kiter48.encode('utf-8') if sys.version_info[0] == 2 else kiter48)
                oprot.writeString(viter49.encode('utf-8') if sys.version_info[0] == 2 else viter49)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_vm_ports_result)
get_vm_ports_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 0
)


class get_flavors_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_flavors_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_flavors_args)
get_flavors_args.thrift_spec = (
)


class get_flavors_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype53, _size50) = iprot.readListBegin()
                    for _i54 in range(_size50):
                        _elem55 = Flavor()
                        _elem55.read(iprot)
                        self.success.append(_elem55)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_flavors_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter56 in self.success:
                iter56.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_flavors_result)
get_flavors_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Flavor, None], False), None, ),  # 0
)


class get_images_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_images_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_images_args)
get_images_args.thrift_spec = (
)


class get_images_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype60, _size57) = iprot.readListBegin()
                    for _i61 in range(_size57):
                        _elem62 = Image()
                        _elem62.read(iprot)
                        self.success.append(_elem62)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_images_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter63 in self.success:
                iter63.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_images_result)
get_images_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Image, None], False), None, ),  # 0
)


class get_public_images_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_public_images_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_public_images_args)
get_public_images_args.thrift_spec = (
)


class get_public_images_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype67, _size64) = iprot.readListBegin()
                    for _i68 in range(_size64):
                        _elem69 = Image()
                        _elem69.read(iprot)
                        self.success.append(_elem69)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_public_images_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter70 in self.success:
                iter70.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_public_images_result)
get_public_images_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Image, None], False), None, ),  # 0
)


class get_private_images_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_private_images_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_private_images_args)
get_private_images_args.thrift_spec = (
)


class get_private_images_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype74, _size71) = iprot.readListBegin()
                    for _i75 in range(_size71):
                        _elem76 = Image()
                        _elem76.read(iprot)
                        self.success.append(_elem76)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_private_images_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter77 in self.success:
                iter77.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_private_images_result)
get_private_images_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Image, None], False), None, ),  # 0
)


class get_image_args(object):
    """
    Attributes:
     - openstack_id

    """


    def __init__(self, openstack_id=None,):
        self.openstack_id = openstack_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.openstack_id = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_image_args')
        if self.openstack_id is not None:
            oprot.writeFieldBegin('openstack_id', TType.STRING, 1)
            oprot.writeString(self.openstack_id.encode('utf-8') if sys.version_info[0] == 2 else self.openstack_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_image_args)
get_image_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'openstack_id', 'UTF8', None, ),  # 1
)


class get_image_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Image()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_image_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_image_result)
get_image_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [Image, None], None, ),  # 0
)


class get_images_by_filter_args(object):
    """
    Attributes:
     - filter_json

    """


    def __init__(self, filter_json=None,):
        self.filter_json = filter_json

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.filter_json = {}
                    (_ktype79, _vtype80, _size78) = iprot.readMapBegin()
                    for _i82 in range(_size78):
                        _key83 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val84 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.filter_json[_key83] = _val84
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_images_by_filter_args')
        if self.filter_json is not None:
            oprot.writeFieldBegin('filter_json', TType.MAP, 1)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.filter_json))
            for kiter85, viter86 in self.filter_json.items():
                oprot.writeString(kiter85.encode('utf-8') if sys.version_info[0] == 2 else kiter85)
                oprot.writeString(viter86.encode('utf-8') if sys.version_info[0] == 2 else viter86)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_images_by_filter_args)
get_images_by_filter_args.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'filter_json', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 1
)


class get_images_by_filter_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype90, _size87) = iprot.readListBegin()
                    for _i91 in range(_size87):
                        _elem92 = Image()
                        _elem92.read(iprot)
                        self.success.append(_elem92)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_images_by_filter_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter93 in self.success:
                iter93.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_images_by_filter_result)
get_images_by_filter_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Image, None], False), None, ),  # 0
)


class get_volume_args(object):
    """
    Attributes:
     - volume_id

    """


    def __init__(self, volume_id=None,):
        self.volume_id = volume_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.volume_id = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_volume_args')
        if self.volume_id is not None:
            oprot.writeFieldBegin('volume_id', TType.STRING, 1)
            oprot.writeString(self.volume_id.encode('utf-8') if sys.version_info[0] == 2 else self.volume_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_volume_args)
get_volume_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'volume_id', 'UTF8', None, ),  # 1
)


class get_volume_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Volume()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_volume_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_volume_result)
get_volume_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [Volume, None], None, ),  # 0
)


class get_volumes_by_ids_args(object):
    """
    Attributes:
     - volume_ids

    """


    def __init__(self, volume_ids=None,):
        self.volume_ids = volume_ids

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.volume_ids = []
                    (_etype97, _size94) = iprot.readListBegin()
                    for _i98 in range(_size94):
                        _elem99 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.volume_ids.append(_elem99)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_volumes_by_ids_args')
        if self.volume_ids is not None:
            oprot.writeFieldBegin('volume_ids', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.volume_ids))
            for iter100 in self.volume_ids:
                oprot.writeString(iter100.encode('utf-8') if sys.version_info[0] == 2 else iter100)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_volumes_by_ids_args)
get_volumes_by_ids_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'volume_ids', (TType.STRING, 'UTF8', False), None, ),  # 1
)


class get_volumes_by_ids_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype104, _size101) = iprot.readListBegin()
                    for _i105 in range(_size101):
                        _elem106 = Volume()
                        _elem106.read(iprot)
                        self.success.append(_elem106)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_volumes_by_ids_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter107 in self.success:
                iter107.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_volumes_by_ids_result)
get_volumes_by_ids_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Volume, None], False), None, ),  # 0
)


class resize_volume_args(object):
    """
    Attributes:
     - volume_id
     - size

    """


    def __init__(self, volume_id=None, size=None,):
        self.volume_id = volume_id
        self.size = size

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.volume_id = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('resize_volume_args')
        if self.volume_id is not None:
            oprot.writeFieldBegin('volume_id', TType.STRING, 1)
            oprot.writeString(self.volume_id.encode('utf-8') if sys.version_info[0] == 2 else self.volume_id)
            oprot.writeFieldEnd()
        if self.size is not None:
            oprot.writeFieldBegin('size', TType.I32, 2)
            oprot.writeI32(self.size)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(resize_volume_args)
resize_volume_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'volume_id', 'UTF8', None, ),  # 1
    (2, TType.I32, 'size', None, None, ),  # 2
)


class resize_volume_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('resize_volume_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(resize_volume_result)
resize_volume_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class delete_server_args(object):
    """
    Attributes:
     - openstack_id: Id of the server.

    """


    def __init__(self, openstack_id=None,):
        self.openstack_id = openstack_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.openstack_id = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('delete_server_args')
        if self.openstack_id is not None:
            oprot.writeFieldBegin('openstack_id', TType.STRING, 1)
            oprot.writeString(self.openstack_id.encode('utf-8') if sys.version_info[0] == 2 else self.openstack_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(delete_server_args)
delete_server_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'openstack_id', 'UTF8', None, ),  # 1
)


class delete_server_result(object):
    """
    Attributes:
     - success
     - e
     - c

    """


    def __init__(self, success=None, e=None, c=None,):
        self.success = success
        self.e = e
        self.c = c

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = serverNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.c = conflictException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('delete_server_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        if self.c is not None:
            oprot.writeFieldBegin('c', TType.STRUCT, 2)
            self.c.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(delete_server_result)
delete_server_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [serverNotFoundException, None], None, ),  # 1
    (2, TType.STRUCT, 'c', [conflictException, None], None, ),  # 2
)


class start_server_args(object):
    """
    Attributes:
     - flavor: Name of the  Flavor to use.
     - image: Name of the image to use.
     - public_key: Public Key to use
     - servername: Name for the new server
     - metadata: Metadata for the new instance
     - research_environment
     - volume_ids_path_new
     - volume_ids_path_attach
     - additional_keys

    """


    def __init__(self, flavor=None, image=None, public_key=None, servername=None, metadata=None, research_environment=None, volume_ids_path_new=None, volume_ids_path_attach=None, additional_keys=None,):
        self.flavor = flavor
        self.image = image
        self.public_key = public_key
        self.servername = servername
        self.metadata = metadata
        self.research_environment = research_environment
        self.volume_ids_path_new = volume_ids_path_new
        self.volume_ids_path_attach = volume_ids_path_attach
        self.additional_keys = additional_keys

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.flavor = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.image = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.public_key = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.servername = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.MAP:
                    self.metadata = {}
                    (_ktype109, _vtype110, _size108) = iprot.readMapBegin()
                    for _i112 in range(_size108):
                        _key113 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val114 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.metadata[_key113] = _val114
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.research_environment = []
                    (_etype118, _size115) = iprot.readListBegin()
                    for _i119 in range(_size115):
                        _elem120 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.research_environment.append(_elem120)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.LIST:
                    self.volume_ids_path_new = []
                    (_etype124, _size121) = iprot.readListBegin()
                    for _i125 in range(_size121):
                        _elem126 = {}
                        (_ktype128, _vtype129, _size127) = iprot.readMapBegin()
                        for _i131 in range(_size127):
                            _key132 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val133 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem126[_key132] = _val133
                        iprot.readMapEnd()
                        self.volume_ids_path_new.append(_elem126)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.LIST:
                    self.volume_ids_path_attach = []
                    (_etype137, _size134) = iprot.readListBegin()
                    for _i138 in range(_size134):
                        _elem139 = {}
                        (_ktype141, _vtype142, _size140) = iprot.readMapBegin()
                        for _i144 in range(_size140):
                            _key145 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val146 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem139[_key145] = _val146
                        iprot.readMapEnd()
                        self.volume_ids_path_attach.append(_elem139)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.LIST:
                    self.additional_keys = []
                    (_etype150, _size147) = iprot.readListBegin()
                    for _i151 in range(_size147):
                        _elem152 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.additional_keys.append(_elem152)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('start_server_args')
        if self.flavor is not None:
            oprot.writeFieldBegin('flavor', TType.STRING, 1)
            oprot.writeString(self.flavor.encode('utf-8') if sys.version_info[0] == 2 else self.flavor)
            oprot.writeFieldEnd()
        if self.image is not None:
            oprot.writeFieldBegin('image', TType.STRING, 2)
            oprot.writeString(self.image.encode('utf-8') if sys.version_info[0] == 2 else self.image)
            oprot.writeFieldEnd()
        if self.public_key is not None:
            oprot.writeFieldBegin('public_key', TType.STRING, 3)
            oprot.writeString(self.public_key.encode('utf-8') if sys.version_info[0] == 2 else self.public_key)
            oprot.writeFieldEnd()
        if self.servername is not None:
            oprot.writeFieldBegin('servername', TType.STRING, 4)
            oprot.writeString(self.servername.encode('utf-8') if sys.version_info[0] == 2 else self.servername)
            oprot.writeFieldEnd()
        if self.metadata is not None:
            oprot.writeFieldBegin('metadata', TType.MAP, 5)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.metadata))
            for kiter153, viter154 in self.metadata.items():
                oprot.writeString(kiter153.encode('utf-8') if sys.version_info[0] == 2 else kiter153)
                oprot.writeString(viter154.encode('utf-8') if sys.version_info[0] == 2 else viter154)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.research_environment is not None:
            oprot.writeFieldBegin('research_environment', TType.LIST, 7)
            oprot.writeListBegin(TType.STRING, len(self.research_environment))
            for iter155 in self.research_environment:
                oprot.writeString(iter155.encode('utf-8') if sys.version_info[0] == 2 else iter155)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.volume_ids_path_new is not None:
            oprot.writeFieldBegin('volume_ids_path_new', TType.LIST, 8)
            oprot.writeListBegin(TType.MAP, len(self.volume_ids_path_new))
            for iter156 in self.volume_ids_path_new:
                oprot.writeMapBegin(TType.STRING, TType.STRING, len(iter156))
                for kiter157, viter158 in iter156.items():
                    oprot.writeString(kiter157.encode('utf-8') if sys.version_info[0] == 2 else kiter157)
                    oprot.writeString(viter158.encode('utf-8') if sys.version_info[0] == 2 else viter158)
                oprot.writeMapEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.volume_ids_path_attach is not None:
            oprot.writeFieldBegin('volume_ids_path_attach', TType.LIST, 9)
            oprot.writeListBegin(TType.MAP, len(self.volume_ids_path_attach))
            for iter159 in self.volume_ids_path_attach:
                oprot.writeMapBegin(TType.STRING, TType.STRING, len(iter159))
                for kiter160, viter161 in iter159.items():
                    oprot.writeString(kiter160.encode('utf-8') if sys.version_info[0] == 2 else kiter160)
                    oprot.writeString(viter161.encode('utf-8') if sys.version_info[0] == 2 else viter161)
                oprot.writeMapEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.additional_keys is not None:
            oprot.writeFieldBegin('additional_keys', TType.LIST, 10)
            oprot.writeListBegin(TType.STRING, len(self.additional_keys))
            for iter162 in self.additional_keys:
                oprot.writeString(iter162.encode('utf-8') if sys.version_info[0] == 2 else iter162)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(start_server_args)
start_server_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'flavor', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'image', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'public_key', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'servername', 'UTF8', None, ),  # 4
    (5, TType.MAP, 'metadata', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 5
    None,  # 6
    (7, TType.LIST, 'research_environment', (TType.STRING, 'UTF8', False), None, ),  # 7
    (8, TType.LIST, 'volume_ids_path_new', (TType.MAP, (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), False), None, ),  # 8
    (9, TType.LIST, 'volume_ids_path_attach', (TType.MAP, (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), False), None, ),  # 9
    (10, TType.LIST, 'additional_keys', (TType.STRING, 'UTF8', False), None, ),  # 10
)


class start_server_result(object):
    """
    Attributes:
     - success
     - e
     - r
     - s
     - n
     - i
     - f
     - o

    """


    def __init__(self, success=None, e=None, r=None, s=None, n=None, i=None, f=None, o=None,):
        self.success = success
        self.e = e
        self.r = r
        self.s = s
        self.n = n
        self.i = i
        self.f = f
        self.o = o

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype164, _vtype165, _size163) = iprot.readMapBegin()
                    for _i167 in range(_size163):
                        _key168 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val169 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success[_key168] = _val169
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = nameException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.r = ressourceException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.s = serverNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.n = networkNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.i = imageNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.f = flavorNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.o = otherException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('start_server_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for kiter170, viter171 in self.success.items():
                oprot.writeString(kiter170.encode('utf-8') if sys.version_info[0] == 2 else kiter170)
                oprot.writeString(viter171.encode('utf-8') if sys.version_info[0] == 2 else viter171)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        if self.r is not None:
            oprot.writeFieldBegin('r', TType.STRUCT, 2)
            self.r.write(oprot)
            oprot.writeFieldEnd()
        if self.s is not None:
            oprot.writeFieldBegin('s', TType.STRUCT, 3)
            self.s.write(oprot)
            oprot.writeFieldEnd()
        if self.n is not None:
            oprot.writeFieldBegin('n', TType.STRUCT, 4)
            self.n.write(oprot)
            oprot.writeFieldEnd()
        if self.i is not None:
            oprot.writeFieldBegin('i', TType.STRUCT, 5)
            self.i.write(oprot)
            oprot.writeFieldEnd()
        if self.f is not None:
            oprot.writeFieldBegin('f', TType.STRUCT, 6)
            self.f.write(oprot)
            oprot.writeFieldEnd()
        if self.o is not None:
            oprot.writeFieldBegin('o', TType.STRUCT, 7)
            self.o.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(start_server_result)
start_server_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'e', [nameException, None], None, ),  # 1
    (2, TType.STRUCT, 'r', [ressourceException, None], None, ),  # 2
    (3, TType.STRUCT, 's', [serverNotFoundException, None], None, ),  # 3
    (4, TType.STRUCT, 'n', [networkNotFoundException, None], None, ),  # 4
    (5, TType.STRUCT, 'i', [imageNotFoundException, None], None, ),  # 5
    (6, TType.STRUCT, 'f', [flavorNotFoundException, None], None, ),  # 6
    (7, TType.STRUCT, 'o', [otherException, None], None, ),  # 7
)


class bibigrid_available_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('bibigrid_available_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(bibigrid_available_args)
bibigrid_available_args.thrift_spec = (
)


class bibigrid_available_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('bibigrid_available_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(bibigrid_available_result)
bibigrid_available_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class detach_ip_from_server_args(object):
    """
    Attributes:
     - server_id
     - floating_ip

    """


    def __init__(self, server_id=None, floating_ip=None,):
        self.server_id = server_id
        self.floating_ip = floating_ip

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.server_id = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.floating_ip = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('detach_ip_from_server_args')
        if self.server_id is not None:
            oprot.writeFieldBegin('server_id', TType.STRING, 1)
            oprot.writeString(self.server_id.encode('utf-8') if sys.version_info[0] == 2 else self.server_id)
            oprot.writeFieldEnd()
        if self.floating_ip is not None:
            oprot.writeFieldBegin('floating_ip', TType.STRING, 2)
            oprot.writeString(self.floating_ip.encode('utf-8') if sys.version_info[0] == 2 else self.floating_ip)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(detach_ip_from_server_args)
detach_ip_from_server_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'server_id', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'floating_ip', 'UTF8', None, ),  # 2
)


class detach_ip_from_server_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('detach_ip_from_server_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(detach_ip_from_server_result)
detach_ip_from_server_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class start_server_with_custom_key_args(object):
    """
    Attributes:
     - flavor: Name of the  Flavor to use.
     - image: Name of the image to use.
     - servername: Name for the new server
     - metadata: Metadata for the new instance
     - research_environment
     - volume_ids_path_new
     - volume_ids_path_attach

    """


    def __init__(self, flavor=None, image=None, servername=None, metadata=None, research_environment=None, volume_ids_path_new=None, volume_ids_path_attach=None,):
        self.flavor = flavor
        self.image = image
        self.servername = servername
        self.metadata = metadata
        self.research_environment = research_environment
        self.volume_ids_path_new = volume_ids_path_new
        self.volume_ids_path_attach = volume_ids_path_attach

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.flavor = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.image = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.servername = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.MAP:
                    self.metadata = {}
                    (_ktype173, _vtype174, _size172) = iprot.readMapBegin()
                    for _i176 in range(_size172):
                        _key177 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val178 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.metadata[_key177] = _val178
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.research_environment = []
                    (_etype182, _size179) = iprot.readListBegin()
                    for _i183 in range(_size179):
                        _elem184 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.research_environment.append(_elem184)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.volume_ids_path_new = []
                    (_etype188, _size185) = iprot.readListBegin()
                    for _i189 in range(_size185):
                        _elem190 = {}
                        (_ktype192, _vtype193, _size191) = iprot.readMapBegin()
                        for _i195 in range(_size191):
                            _key196 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val197 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem190[_key196] = _val197
                        iprot.readMapEnd()
                        self.volume_ids_path_new.append(_elem190)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.volume_ids_path_attach = []
                    (_etype201, _size198) = iprot.readListBegin()
                    for _i202 in range(_size198):
                        _elem203 = {}
                        (_ktype205, _vtype206, _size204) = iprot.readMapBegin()
                        for _i208 in range(_size204):
                            _key209 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val210 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem203[_key209] = _val210
                        iprot.readMapEnd()
                        self.volume_ids_path_attach.append(_elem203)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('start_server_with_custom_key_args')
        if self.flavor is not None:
            oprot.writeFieldBegin('flavor', TType.STRING, 1)
            oprot.writeString(self.flavor.encode('utf-8') if sys.version_info[0] == 2 else self.flavor)
            oprot.writeFieldEnd()
        if self.image is not None:
            oprot.writeFieldBegin('image', TType.STRING, 2)
            oprot.writeString(self.image.encode('utf-8') if sys.version_info[0] == 2 else self.image)
            oprot.writeFieldEnd()
        if self.servername is not None:
            oprot.writeFieldBegin('servername', TType.STRING, 3)
            oprot.writeString(self.servername.encode('utf-8') if sys.version_info[0] == 2 else self.servername)
            oprot.writeFieldEnd()
        if self.metadata is not None:
            oprot.writeFieldBegin('metadata', TType.MAP, 4)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.metadata))
            for kiter211, viter212 in self.metadata.items():
                oprot.writeString(kiter211.encode('utf-8') if sys.version_info[0] == 2 else kiter211)
                oprot.writeString(viter212.encode('utf-8') if sys.version_info[0] == 2 else viter212)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.research_environment is not None:
            oprot.writeFieldBegin('research_environment', TType.LIST, 5)
            oprot.writeListBegin(TType.STRING, len(self.research_environment))
            for iter213 in self.research_environment:
                oprot.writeString(iter213.encode('utf-8') if sys.version_info[0] == 2 else iter213)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.volume_ids_path_new is not None:
            oprot.writeFieldBegin('volume_ids_path_new', TType.LIST, 6)
            oprot.writeListBegin(TType.MAP, len(self.volume_ids_path_new))
            for iter214 in self.volume_ids_path_new:
                oprot.writeMapBegin(TType.STRING, TType.STRING, len(iter214))
                for kiter215, viter216 in iter214.items():
                    oprot.writeString(kiter215.encode('utf-8') if sys.version_info[0] == 2 else kiter215)
                    oprot.writeString(viter216.encode('utf-8') if sys.version_info[0] == 2 else viter216)
                oprot.writeMapEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.volume_ids_path_attach is not None:
            oprot.writeFieldBegin('volume_ids_path_attach', TType.LIST, 7)
            oprot.writeListBegin(TType.MAP, len(self.volume_ids_path_attach))
            for iter217 in self.volume_ids_path_attach:
                oprot.writeMapBegin(TType.STRING, TType.STRING, len(iter217))
                for kiter218, viter219 in iter217.items():
                    oprot.writeString(kiter218.encode('utf-8') if sys.version_info[0] == 2 else kiter218)
                    oprot.writeString(viter219.encode('utf-8') if sys.version_info[0] == 2 else viter219)
                oprot.writeMapEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(start_server_with_custom_key_args)
start_server_with_custom_key_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'flavor', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'image', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'servername', 'UTF8', None, ),  # 3
    (4, TType.MAP, 'metadata', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 4
    (5, TType.LIST, 'research_environment', (TType.STRING, 'UTF8', False), None, ),  # 5
    (6, TType.LIST, 'volume_ids_path_new', (TType.MAP, (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), False), None, ),  # 6
    (7, TType.LIST, 'volume_ids_path_attach', (TType.MAP, (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), False), None, ),  # 7
)


class start_server_with_custom_key_result(object):
    """
    Attributes:
     - success
     - e
     - r
     - s
     - n
     - i
     - f
     - o

    """


    def __init__(self, success=None, e=None, r=None, s=None, n=None, i=None, f=None, o=None,):
        self.success = success
        self.e = e
        self.r = r
        self.s = s
        self.n = n
        self.i = i
        self.f = f
        self.o = o

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype221, _vtype222, _size220) = iprot.readMapBegin()
                    for _i224 in range(_size220):
                        _key225 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val226 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success[_key225] = _val226
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = nameException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.r = ressourceException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.s = serverNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.n = networkNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.i = imageNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.f = flavorNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.o = otherException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('start_server_with_custom_key_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for kiter227, viter228 in self.success.items():
                oprot.writeString(kiter227.encode('utf-8') if sys.version_info[0] == 2 else kiter227)
                oprot.writeString(viter228.encode('utf-8') if sys.version_info[0] == 2 else viter228)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        if self.r is not None:
            oprot.writeFieldBegin('r', TType.STRUCT, 2)
            self.r.write(oprot)
            oprot.writeFieldEnd()
        if self.s is not None:
            oprot.writeFieldBegin('s', TType.STRUCT, 3)
            self.s.write(oprot)
            oprot.writeFieldEnd()
        if self.n is not None:
            oprot.writeFieldBegin('n', TType.STRUCT, 4)
            self.n.write(oprot)
            oprot.writeFieldEnd()
        if self.i is not None:
            oprot.writeFieldBegin('i', TType.STRUCT, 5)
            self.i.write(oprot)
            oprot.writeFieldEnd()
        if self.f is not None:
            oprot.writeFieldBegin('f', TType.STRUCT, 6)
            self.f.write(oprot)
            oprot.writeFieldEnd()
        if self.o is not None:
            oprot.writeFieldBegin('o', TType.STRUCT, 7)
            self.o.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(start_server_with_custom_key_result)
start_server_with_custom_key_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'e', [nameException, None], None, ),  # 1
    (2, TType.STRUCT, 'r', [ressourceException, None], None, ),  # 2
    (3, TType.STRUCT, 's', [serverNotFoundException, None], None, ),  # 3
    (4, TType.STRUCT, 'n', [networkNotFoundException, None], None, ),  # 4
    (5, TType.STRUCT, 'i', [imageNotFoundException, None], None, ),  # 5
    (6, TType.STRUCT, 'f', [flavorNotFoundException, None], None, ),  # 6
    (7, TType.STRUCT, 'o', [otherException, None], None, ),  # 7
)


class exist_server_args(object):
    """
    Attributes:
     - name

    """


    def __init__(self, name=None,):
        self.name = name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('exist_server_args')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(exist_server_args)
exist_server_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
)


class exist_server_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('exist_server_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(exist_server_result)
exist_server_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class create_and_deploy_playbook_args(object):
    """
    Attributes:
     - public_key
     - playbooks_information
     - openstack_id

    """


    def __init__(self, public_key=None, playbooks_information=None, openstack_id=None,):
        self.public_key = public_key
        self.playbooks_information = playbooks_information
        self.openstack_id = openstack_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.public_key = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.playbooks_information = {}
                    (_ktype230, _vtype231, _size229) = iprot.readMapBegin()
                    for _i233 in range(_size229):
                        _key234 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val235 = {}
                        (_ktype237, _vtype238, _size236) = iprot.readMapBegin()
                        for _i240 in range(_size236):
                            _key241 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val242 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val235[_key241] = _val242
                        iprot.readMapEnd()
                        self.playbooks_information[_key234] = _val235
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.openstack_id = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_and_deploy_playbook_args')
        if self.public_key is not None:
            oprot.writeFieldBegin('public_key', TType.STRING, 1)
            oprot.writeString(self.public_key.encode('utf-8') if sys.version_info[0] == 2 else self.public_key)
            oprot.writeFieldEnd()
        if self.playbooks_information is not None:
            oprot.writeFieldBegin('playbooks_information', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.playbooks_information))
            for kiter243, viter244 in self.playbooks_information.items():
                oprot.writeString(kiter243.encode('utf-8') if sys.version_info[0] == 2 else kiter243)
                oprot.writeMapBegin(TType.STRING, TType.STRING, len(viter244))
                for kiter245, viter246 in viter244.items():
                    oprot.writeString(kiter245.encode('utf-8') if sys.version_info[0] == 2 else kiter245)
                    oprot.writeString(viter246.encode('utf-8') if sys.version_info[0] == 2 else viter246)
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.openstack_id is not None:
            oprot.writeFieldBegin('openstack_id', TType.STRING, 3)
            oprot.writeString(self.openstack_id.encode('utf-8') if sys.version_info[0] == 2 else self.openstack_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_and_deploy_playbook_args)
create_and_deploy_playbook_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'public_key', 'UTF8', None, ),  # 1
    (2, TType.MAP, 'playbooks_information', (TType.STRING, 'UTF8', TType.MAP, (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), False), None, ),  # 2
    (3, TType.STRING, 'openstack_id', 'UTF8', None, ),  # 3
)


class create_and_deploy_playbook_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_and_deploy_playbook_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_and_deploy_playbook_result)
create_and_deploy_playbook_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class get_playbook_logs_args(object):
    """
    Attributes:
     - openstack_id

    """


    def __init__(self, openstack_id=None,):
        self.openstack_id = openstack_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.openstack_id = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_playbook_logs_args')
        if self.openstack_id is not None:
            oprot.writeFieldBegin('openstack_id', TType.STRING, 1)
            oprot.writeString(self.openstack_id.encode('utf-8') if sys.version_info[0] == 2 else self.openstack_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_playbook_logs_args)
get_playbook_logs_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'openstack_id', 'UTF8', None, ),  # 1
)


class get_playbook_logs_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = PlaybookResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_playbook_logs_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_playbook_logs_result)
get_playbook_logs_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [PlaybookResult, None], None, ),  # 0
)


class has_forc_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('has_forc_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(has_forc_args)
has_forc_args.thrift_spec = (
)


class has_forc_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('has_forc_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(has_forc_result)
has_forc_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class get_forc_url_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_forc_url_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_forc_url_args)
get_forc_url_args.thrift_spec = (
)


class get_forc_url_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_forc_url_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_forc_url_result)
get_forc_url_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class create_backend_args(object):
    """
    Attributes:
     - elixir_id
     - user_key_url
     - template
     - upstream_url

    """


    def __init__(self, elixir_id=None, user_key_url=None, template=None, upstream_url=None,):
        self.elixir_id = elixir_id
        self.user_key_url = user_key_url
        self.template = template
        self.upstream_url = upstream_url

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.elixir_id = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.user_key_url = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.template = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.upstream_url = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_backend_args')
        if self.elixir_id is not None:
            oprot.writeFieldBegin('elixir_id', TType.STRING, 1)
            oprot.writeString(self.elixir_id.encode('utf-8') if sys.version_info[0] == 2 else self.elixir_id)
            oprot.writeFieldEnd()
        if self.user_key_url is not None:
            oprot.writeFieldBegin('user_key_url', TType.STRING, 2)
            oprot.writeString(self.user_key_url.encode('utf-8') if sys.version_info[0] == 2 else self.user_key_url)
            oprot.writeFieldEnd()
        if self.template is not None:
            oprot.writeFieldBegin('template', TType.STRING, 3)
            oprot.writeString(self.template.encode('utf-8') if sys.version_info[0] == 2 else self.template)
            oprot.writeFieldEnd()
        if self.upstream_url is not None:
            oprot.writeFieldBegin('upstream_url', TType.STRING, 4)
            oprot.writeString(self.upstream_url.encode('utf-8') if sys.version_info[0] == 2 else self.upstream_url)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_backend_args)
create_backend_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'elixir_id', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'user_key_url', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'template', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'upstream_url', 'UTF8', None, ),  # 4
)


class create_backend_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Backend()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_backend_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_backend_result)
create_backend_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [Backend, None], None, ),  # 0
)


class get_backends_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_backends_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_backends_args)
get_backends_args.thrift_spec = (
)


class get_backends_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype250, _size247) = iprot.readListBegin()
                    for _i251 in range(_size247):
                        _elem252 = Backend()
                        _elem252.read(iprot)
                        self.success.append(_elem252)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_backends_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter253 in self.success:
                iter253.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_backends_result)
get_backends_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Backend, None], False), None, ),  # 0
)


class get_backends_by_owner_args(object):
    """
    Attributes:
     - elixir_id

    """


    def __init__(self, elixir_id=None,):
        self.elixir_id = elixir_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.elixir_id = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_backends_by_owner_args')
        if self.elixir_id is not None:
            oprot.writeFieldBegin('elixir_id', TType.STRING, 1)
            oprot.writeString(self.elixir_id.encode('utf-8') if sys.version_info[0] == 2 else self.elixir_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_backends_by_owner_args)
get_backends_by_owner_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'elixir_id', 'UTF8', None, ),  # 1
)


class get_backends_by_owner_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype257, _size254) = iprot.readListBegin()
                    for _i258 in range(_size254):
                        _elem259 = Backend()
                        _elem259.read(iprot)
                        self.success.append(_elem259)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_backends_by_owner_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter260 in self.success:
                iter260.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_backends_by_owner_result)
get_backends_by_owner_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Backend, None], False), None, ),  # 0
)


class get_backends_by_template_args(object):
    """
    Attributes:
     - template

    """


    def __init__(self, template=None,):
        self.template = template

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.template = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_backends_by_template_args')
        if self.template is not None:
            oprot.writeFieldBegin('template', TType.STRING, 1)
            oprot.writeString(self.template.encode('utf-8') if sys.version_info[0] == 2 else self.template)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_backends_by_template_args)
get_backends_by_template_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'template', 'UTF8', None, ),  # 1
)


class get_backends_by_template_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype264, _size261) = iprot.readListBegin()
                    for _i265 in range(_size261):
                        _elem266 = Backend()
                        _elem266.read(iprot)
                        self.success.append(_elem266)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_backends_by_template_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter267 in self.success:
                iter267.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_backends_by_template_result)
get_backends_by_template_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Backend, None], False), None, ),  # 0
)


class get_backend_by_id_args(object):
    """
    Attributes:
     - id

    """


    def __init__(self, id=None,):
        self.id = id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_backend_by_id_args')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I64, 1)
            oprot.writeI64(self.id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_backend_by_id_args)
get_backend_by_id_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'id', None, None, ),  # 1
)


class get_backend_by_id_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Backend()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_backend_by_id_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_backend_by_id_result)
get_backend_by_id_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [Backend, None], None, ),  # 0
)


class delete_backend_args(object):
    """
    Attributes:
     - id

    """


    def __init__(self, id=None,):
        self.id = id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('delete_backend_args')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I64, 1)
            oprot.writeI64(self.id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(delete_backend_args)
delete_backend_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'id', None, None, ),  # 1
)


class delete_backend_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('delete_backend_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(delete_backend_result)
delete_backend_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class add_user_to_backend_args(object):
    """
    Attributes:
     - backend_id
     - owner_id
     - user_id

    """


    def __init__(self, backend_id=None, owner_id=None, user_id=None,):
        self.backend_id = backend_id
        self.owner_id = owner_id
        self.user_id = user_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.backend_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.owner_id = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.user_id = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_user_to_backend_args')
        if self.backend_id is not None:
            oprot.writeFieldBegin('backend_id', TType.I64, 1)
            oprot.writeI64(self.backend_id)
            oprot.writeFieldEnd()
        if self.owner_id is not None:
            oprot.writeFieldBegin('owner_id', TType.STRING, 2)
            oprot.writeString(self.owner_id.encode('utf-8') if sys.version_info[0] == 2 else self.owner_id)
            oprot.writeFieldEnd()
        if self.user_id is not None:
            oprot.writeFieldBegin('user_id', TType.STRING, 3)
            oprot.writeString(self.user_id.encode('utf-8') if sys.version_info[0] == 2 else self.user_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_user_to_backend_args)
add_user_to_backend_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'backend_id', None, None, ),  # 1
    (2, TType.STRING, 'owner_id', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'user_id', 'UTF8', None, ),  # 3
)


class add_user_to_backend_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype269, _vtype270, _size268) = iprot.readMapBegin()
                    for _i272 in range(_size268):
                        _key273 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val274 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success[_key273] = _val274
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_user_to_backend_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for kiter275, viter276 in self.success.items():
                oprot.writeString(kiter275.encode('utf-8') if sys.version_info[0] == 2 else kiter275)
                oprot.writeString(viter276.encode('utf-8') if sys.version_info[0] == 2 else viter276)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_user_to_backend_result)
add_user_to_backend_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 0
)


class get_users_from_backend_args(object):
    """
    Attributes:
     - backend_id

    """


    def __init__(self, backend_id=None,):
        self.backend_id = backend_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.backend_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_users_from_backend_args')
        if self.backend_id is not None:
            oprot.writeFieldBegin('backend_id', TType.I64, 1)
            oprot.writeI64(self.backend_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_users_from_backend_args)
get_users_from_backend_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'backend_id', None, None, ),  # 1
)


class get_users_from_backend_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype280, _size277) = iprot.readListBegin()
                    for _i281 in range(_size277):
                        _elem282 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem282)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_users_from_backend_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter283 in self.success:
                oprot.writeString(iter283.encode('utf-8') if sys.version_info[0] == 2 else iter283)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_users_from_backend_result)
get_users_from_backend_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
)


class delete_user_from_backend_args(object):
    """
    Attributes:
     - backend_id
     - owner_id
     - user_id

    """


    def __init__(self, backend_id=None, owner_id=None, user_id=None,):
        self.backend_id = backend_id
        self.owner_id = owner_id
        self.user_id = user_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.backend_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.owner_id = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.user_id = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('delete_user_from_backend_args')
        if self.backend_id is not None:
            oprot.writeFieldBegin('backend_id', TType.I64, 1)
            oprot.writeI64(self.backend_id)
            oprot.writeFieldEnd()
        if self.owner_id is not None:
            oprot.writeFieldBegin('owner_id', TType.STRING, 2)
            oprot.writeString(self.owner_id.encode('utf-8') if sys.version_info[0] == 2 else self.owner_id)
            oprot.writeFieldEnd()
        if self.user_id is not None:
            oprot.writeFieldBegin('user_id', TType.STRING, 3)
            oprot.writeString(self.user_id.encode('utf-8') if sys.version_info[0] == 2 else self.user_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(delete_user_from_backend_args)
delete_user_from_backend_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'backend_id', None, None, ),  # 1
    (2, TType.STRING, 'owner_id', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'user_id', 'UTF8', None, ),  # 3
)


class delete_user_from_backend_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype285, _vtype286, _size284) = iprot.readMapBegin()
                    for _i288 in range(_size284):
                        _key289 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val290 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success[_key289] = _val290
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('delete_user_from_backend_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for kiter291, viter292 in self.success.items():
                oprot.writeString(kiter291.encode('utf-8') if sys.version_info[0] == 2 else kiter291)
                oprot.writeString(viter292.encode('utf-8') if sys.version_info[0] == 2 else viter292)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(delete_user_from_backend_result)
delete_user_from_backend_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 0
)


class get_templates_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_templates_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_templates_args)
get_templates_args.thrift_spec = (
)


class get_templates_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype296, _size293) = iprot.readListBegin()
                    for _i297 in range(_size293):
                        _elem298 = {}
                        (_ktype300, _vtype301, _size299) = iprot.readMapBegin()
                        for _i303 in range(_size299):
                            _key304 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val305 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem298[_key304] = _val305
                        iprot.readMapEnd()
                        self.success.append(_elem298)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_templates_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.MAP, len(self.success))
            for iter306 in self.success:
                oprot.writeMapBegin(TType.STRING, TType.STRING, len(iter306))
                for kiter307, viter308 in iter306.items():
                    oprot.writeString(kiter307.encode('utf-8') if sys.version_info[0] == 2 else kiter307)
                    oprot.writeString(viter308.encode('utf-8') if sys.version_info[0] == 2 else viter308)
                oprot.writeMapEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_templates_result)
get_templates_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.MAP, (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), False), None, ),  # 0
)


class get_allowed_templates_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_allowed_templates_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_allowed_templates_args)
get_allowed_templates_args.thrift_spec = (
)


class get_allowed_templates_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype312, _size309) = iprot.readListBegin()
                    for _i313 in range(_size309):
                        _elem314 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem314)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_allowed_templates_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter315 in self.success:
                oprot.writeString(iter315.encode('utf-8') if sys.version_info[0] == 2 else iter315)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_allowed_templates_result)
get_allowed_templates_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
)


class get_templates_by_template_args(object):
    """
    Attributes:
     - template_name

    """


    def __init__(self, template_name=None,):
        self.template_name = template_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.template_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_templates_by_template_args')
        if self.template_name is not None:
            oprot.writeFieldBegin('template_name', TType.STRING, 1)
            oprot.writeString(self.template_name.encode('utf-8') if sys.version_info[0] == 2 else self.template_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_templates_by_template_args)
get_templates_by_template_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'template_name', 'UTF8', None, ),  # 1
)


class get_templates_by_template_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype319, _size316) = iprot.readListBegin()
                    for _i320 in range(_size316):
                        _elem321 = {}
                        (_ktype323, _vtype324, _size322) = iprot.readMapBegin()
                        for _i326 in range(_size322):
                            _key327 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val328 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem321[_key327] = _val328
                        iprot.readMapEnd()
                        self.success.append(_elem321)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_templates_by_template_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.MAP, len(self.success))
            for iter329 in self.success:
                oprot.writeMapBegin(TType.STRING, TType.STRING, len(iter329))
                for kiter330, viter331 in iter329.items():
                    oprot.writeString(kiter330.encode('utf-8') if sys.version_info[0] == 2 else kiter330)
                    oprot.writeString(viter331.encode('utf-8') if sys.version_info[0] == 2 else viter331)
                oprot.writeMapEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_templates_by_template_result)
get_templates_by_template_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.MAP, (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), False), None, ),  # 0
)


class check_template_args(object):
    """
    Attributes:
     - template_name
     - template_version

    """


    def __init__(self, template_name=None, template_version=None,):
        self.template_name = template_name
        self.template_version = template_version

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.template_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.template_version = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('check_template_args')
        if self.template_name is not None:
            oprot.writeFieldBegin('template_name', TType.STRING, 1)
            oprot.writeString(self.template_name.encode('utf-8') if sys.version_info[0] == 2 else self.template_name)
            oprot.writeFieldEnd()
        if self.template_version is not None:
            oprot.writeFieldBegin('template_version', TType.STRING, 2)
            oprot.writeString(self.template_version.encode('utf-8') if sys.version_info[0] == 2 else self.template_version)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(check_template_args)
check_template_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'template_name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'template_version', 'UTF8', None, ),  # 2
)


class check_template_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype333, _vtype334, _size332) = iprot.readMapBegin()
                    for _i336 in range(_size332):
                        _key337 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val338 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success[_key337] = _val338
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('check_template_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for kiter339, viter340 in self.success.items():
                oprot.writeString(kiter339.encode('utf-8') if sys.version_info[0] == 2 else kiter339)
                oprot.writeString(viter340.encode('utf-8') if sys.version_info[0] == 2 else viter340)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(check_template_result)
check_template_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 0
)


class add_udp_security_group_args(object):
    """
    Attributes:
     - server_id: OpenStack id of the server

    """


    def __init__(self, server_id=None,):
        self.server_id = server_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.server_id = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_udp_security_group_args')
        if self.server_id is not None:
            oprot.writeFieldBegin('server_id', TType.STRING, 1)
            oprot.writeString(self.server_id.encode('utf-8') if sys.version_info[0] == 2 else self.server_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_udp_security_group_args)
add_udp_security_group_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'server_id', 'UTF8', None, ),  # 1
)


class add_udp_security_group_result(object):
    """
    Attributes:
     - success
     - r
     - s

    """


    def __init__(self, success=None, r=None, s=None,):
        self.success = success
        self.r = r
        self.s = s

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.r = ressourceException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.s = serverNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_udp_security_group_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.r is not None:
            oprot.writeFieldBegin('r', TType.STRUCT, 1)
            self.r.write(oprot)
            oprot.writeFieldEnd()
        if self.s is not None:
            oprot.writeFieldBegin('s', TType.STRUCT, 2)
            self.s.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_udp_security_group_result)
add_udp_security_group_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'r', [ressourceException, None], None, ),  # 1
    (2, TType.STRUCT, 's', [serverNotFoundException, None], None, ),  # 2
)


class get_servers_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_servers_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_servers_args)
get_servers_args.thrift_spec = (
)


class get_servers_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype344, _size341) = iprot.readListBegin()
                    for _i345 in range(_size341):
                        _elem346 = VM()
                        _elem346.read(iprot)
                        self.success.append(_elem346)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_servers_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter347 in self.success:
                iter347.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_servers_result)
get_servers_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [VM, None], False), None, ),  # 0
)


class get_servers_by_ids_args(object):
    """
    Attributes:
     - server_ids

    """


    def __init__(self, server_ids=None,):
        self.server_ids = server_ids

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.server_ids = []
                    (_etype351, _size348) = iprot.readListBegin()
                    for _i352 in range(_size348):
                        _elem353 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.server_ids.append(_elem353)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_servers_by_ids_args')
        if self.server_ids is not None:
            oprot.writeFieldBegin('server_ids', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.server_ids))
            for iter354 in self.server_ids:
                oprot.writeString(iter354.encode('utf-8') if sys.version_info[0] == 2 else iter354)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_servers_by_ids_args)
get_servers_by_ids_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'server_ids', (TType.STRING, 'UTF8', False), None, ),  # 1
)


class get_servers_by_ids_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype358, _size355) = iprot.readListBegin()
                    for _i359 in range(_size355):
                        _elem360 = VM()
                        _elem360.read(iprot)
                        self.success.append(_elem360)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_servers_by_ids_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter361 in self.success:
                iter361.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_servers_by_ids_result)
get_servers_by_ids_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [VM, None], False), None, ),  # 0
)


class check_server_task_state_args(object):
    """
    Attributes:
     - openstack_id

    """


    def __init__(self, openstack_id=None,):
        self.openstack_id = openstack_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.openstack_id = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('check_server_task_state_args')
        if self.openstack_id is not None:
            oprot.writeFieldBegin('openstack_id', TType.STRING, 1)
            oprot.writeString(self.openstack_id.encode('utf-8') if sys.version_info[0] == 2 else self.openstack_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(check_server_task_state_args)
check_server_task_state_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'openstack_id', 'UTF8', None, ),  # 1
)


class check_server_task_state_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('check_server_task_state_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(check_server_task_state_result)
check_server_task_state_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class get_servers_by_bibigrid_id_args(object):
    """
    Attributes:
     - bibigrid_id

    """


    def __init__(self, bibigrid_id=None,):
        self.bibigrid_id = bibigrid_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.bibigrid_id = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_servers_by_bibigrid_id_args')
        if self.bibigrid_id is not None:
            oprot.writeFieldBegin('bibigrid_id', TType.STRING, 1)
            oprot.writeString(self.bibigrid_id.encode('utf-8') if sys.version_info[0] == 2 else self.bibigrid_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_servers_by_bibigrid_id_args)
get_servers_by_bibigrid_id_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'bibigrid_id', 'UTF8', None, ),  # 1
)


class get_servers_by_bibigrid_id_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype365, _size362) = iprot.readListBegin()
                    for _i366 in range(_size362):
                        _elem367 = VM()
                        _elem367.read(iprot)
                        self.success.append(_elem367)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_servers_by_bibigrid_id_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter368 in self.success:
                iter368.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_servers_by_bibigrid_id_result)
get_servers_by_bibigrid_id_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [VM, None], False), None, ),  # 0
)


class scale_up_cluster_args(object):
    """
    Attributes:
     - cluster_id
     - image
     - flavor
     - count
     - names
     - start_idx
     - batch_idx

    """


    def __init__(self, cluster_id=None, image=None, flavor=None, count=None, names=None, start_idx=None, batch_idx=None,):
        self.cluster_id = cluster_id
        self.image = image
        self.flavor = flavor
        self.count = count
        self.names = names
        self.start_idx = start_idx
        self.batch_idx = batch_idx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.cluster_id = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.image = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.flavor = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.names = []
                    (_etype372, _size369) = iprot.readListBegin()
                    for _i373 in range(_size369):
                        _elem374 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.names.append(_elem374)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.start_idx = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.batch_idx = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('scale_up_cluster_args')
        if self.cluster_id is not None:
            oprot.writeFieldBegin('cluster_id', TType.STRING, 1)
            oprot.writeString(self.cluster_id.encode('utf-8') if sys.version_info[0] == 2 else self.cluster_id)
            oprot.writeFieldEnd()
        if self.image is not None:
            oprot.writeFieldBegin('image', TType.STRING, 2)
            oprot.writeString(self.image.encode('utf-8') if sys.version_info[0] == 2 else self.image)
            oprot.writeFieldEnd()
        if self.flavor is not None:
            oprot.writeFieldBegin('flavor', TType.STRING, 3)
            oprot.writeString(self.flavor.encode('utf-8') if sys.version_info[0] == 2 else self.flavor)
            oprot.writeFieldEnd()
        if self.count is not None:
            oprot.writeFieldBegin('count', TType.I32, 4)
            oprot.writeI32(self.count)
            oprot.writeFieldEnd()
        if self.names is not None:
            oprot.writeFieldBegin('names', TType.LIST, 5)
            oprot.writeListBegin(TType.STRING, len(self.names))
            for iter375 in self.names:
                oprot.writeString(iter375.encode('utf-8') if sys.version_info[0] == 2 else iter375)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.start_idx is not None:
            oprot.writeFieldBegin('start_idx', TType.I32, 6)
            oprot.writeI32(self.start_idx)
            oprot.writeFieldEnd()
        if self.batch_idx is not None:
            oprot.writeFieldBegin('batch_idx', TType.I32, 7)
            oprot.writeI32(self.batch_idx)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(scale_up_cluster_args)
scale_up_cluster_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'cluster_id', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'image', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'flavor', 'UTF8', None, ),  # 3
    (4, TType.I32, 'count', None, None, ),  # 4
    (5, TType.LIST, 'names', (TType.STRING, 'UTF8', False), None, ),  # 5
    (6, TType.I32, 'start_idx', None, None, ),  # 6
    (7, TType.I32, 'batch_idx', None, None, ),  # 7
)


class scale_up_cluster_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype377, _vtype378, _size376) = iprot.readMapBegin()
                    for _i380 in range(_size376):
                        _key381 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val382 = []
                        (_etype386, _size383) = iprot.readListBegin()
                        for _i387 in range(_size383):
                            _elem388 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val382.append(_elem388)
                        iprot.readListEnd()
                        self.success[_key381] = _val382
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('scale_up_cluster_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.success))
            for kiter389, viter390 in self.success.items():
                oprot.writeString(kiter389.encode('utf-8') if sys.version_info[0] == 2 else kiter389)
                oprot.writeListBegin(TType.STRING, len(viter390))
                for iter391 in viter390:
                    oprot.writeString(iter391.encode('utf-8') if sys.version_info[0] == 2 else iter391)
                oprot.writeListEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(scale_up_cluster_result)
scale_up_cluster_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.LIST, (TType.STRING, 'UTF8', False), False), None, ),  # 0
)


class add_cluster_machine_args(object):
    """
    Attributes:
     - cluster_id
     - cluster_user
     - cluster_group_id
     - image
     - flavor
     - name
     - key_name
     - batch_idx
     - worker_idx

    """


    def __init__(self, cluster_id=None, cluster_user=None, cluster_group_id=None, image=None, flavor=None, name=None, key_name=None, batch_idx=None, worker_idx=None,):
        self.cluster_id = cluster_id
        self.cluster_user = cluster_user
        self.cluster_group_id = cluster_group_id
        self.image = image
        self.flavor = flavor
        self.name = name
        self.key_name = key_name
        self.batch_idx = batch_idx
        self.worker_idx = worker_idx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.cluster_id = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.cluster_user = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.cluster_group_id = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.image = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.flavor = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.key_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.batch_idx = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I32:
                    self.worker_idx = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_cluster_machine_args')
        if self.cluster_id is not None:
            oprot.writeFieldBegin('cluster_id', TType.STRING, 1)
            oprot.writeString(self.cluster_id.encode('utf-8') if sys.version_info[0] == 2 else self.cluster_id)
            oprot.writeFieldEnd()
        if self.cluster_user is not None:
            oprot.writeFieldBegin('cluster_user', TType.STRING, 2)
            oprot.writeString(self.cluster_user.encode('utf-8') if sys.version_info[0] == 2 else self.cluster_user)
            oprot.writeFieldEnd()
        if self.cluster_group_id is not None:
            oprot.writeFieldBegin('cluster_group_id', TType.STRING, 3)
            oprot.writeString(self.cluster_group_id.encode('utf-8') if sys.version_info[0] == 2 else self.cluster_group_id)
            oprot.writeFieldEnd()
        if self.image is not None:
            oprot.writeFieldBegin('image', TType.STRING, 4)
            oprot.writeString(self.image.encode('utf-8') if sys.version_info[0] == 2 else self.image)
            oprot.writeFieldEnd()
        if self.flavor is not None:
            oprot.writeFieldBegin('flavor', TType.STRING, 5)
            oprot.writeString(self.flavor.encode('utf-8') if sys.version_info[0] == 2 else self.flavor)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 6)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.key_name is not None:
            oprot.writeFieldBegin('key_name', TType.STRING, 7)
            oprot.writeString(self.key_name.encode('utf-8') if sys.version_info[0] == 2 else self.key_name)
            oprot.writeFieldEnd()
        if self.batch_idx is not None:
            oprot.writeFieldBegin('batch_idx', TType.I32, 8)
            oprot.writeI32(self.batch_idx)
            oprot.writeFieldEnd()
        if self.worker_idx is not None:
            oprot.writeFieldBegin('worker_idx', TType.I32, 9)
            oprot.writeI32(self.worker_idx)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_cluster_machine_args)
add_cluster_machine_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'cluster_id', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'cluster_user', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'cluster_group_id', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'image', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'flavor', 'UTF8', None, ),  # 5
    (6, TType.STRING, 'name', 'UTF8', None, ),  # 6
    (7, TType.STRING, 'key_name', 'UTF8', None, ),  # 7
    (8, TType.I32, 'batch_idx', None, None, ),  # 8
    (9, TType.I32, 'worker_idx', None, None, ),  # 9
)


class add_cluster_machine_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_cluster_machine_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_cluster_machine_result)
add_cluster_machine_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class get_cluster_info_args(object):
    """
    Attributes:
     - cluster_id

    """


    def __init__(self, cluster_id=None,):
        self.cluster_id = cluster_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.cluster_id = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_cluster_info_args')
        if self.cluster_id is not None:
            oprot.writeFieldBegin('cluster_id', TType.STRING, 1)
            oprot.writeString(self.cluster_id.encode('utf-8') if sys.version_info[0] == 2 else self.cluster_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_cluster_info_args)
get_cluster_info_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'cluster_id', 'UTF8', None, ),  # 1
)


class get_cluster_info_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ClusterInfo()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_cluster_info_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_cluster_info_result)
get_cluster_info_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ClusterInfo, None], None, ),  # 0
)


class get_cluster_status_args(object):
    """
    Attributes:
     - cluster_id

    """


    def __init__(self, cluster_id=None,):
        self.cluster_id = cluster_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.cluster_id = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_cluster_status_args')
        if self.cluster_id is not None:
            oprot.writeFieldBegin('cluster_id', TType.STRING, 1)
            oprot.writeString(self.cluster_id.encode('utf-8') if sys.version_info[0] == 2 else self.cluster_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_cluster_status_args)
get_cluster_status_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'cluster_id', 'UTF8', None, ),  # 1
)


class get_cluster_status_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype393, _vtype394, _size392) = iprot.readMapBegin()
                    for _i396 in range(_size392):
                        _key397 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val398 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success[_key397] = _val398
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_cluster_status_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for kiter399, viter400 in self.success.items():
                oprot.writeString(kiter399.encode('utf-8') if sys.version_info[0] == 2 else kiter399)
                oprot.writeString(viter400.encode('utf-8') if sys.version_info[0] == 2 else viter400)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_cluster_status_result)
get_cluster_status_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 0
)


class get_server_args(object):
    """
    Attributes:
     - openstack_id: Id of the server.

    """


    def __init__(self, openstack_id=None,):
        self.openstack_id = openstack_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.openstack_id = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_server_args')
        if self.openstack_id is not None:
            oprot.writeFieldBegin('openstack_id', TType.STRING, 1)
            oprot.writeString(self.openstack_id.encode('utf-8') if sys.version_info[0] == 2 else self.openstack_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_server_args)
get_server_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'openstack_id', 'UTF8', None, ),  # 1
)


class get_server_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = VM()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = serverNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_server_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_server_result)
get_server_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [VM, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [serverNotFoundException, None], None, ),  # 1
)


class stop_server_args(object):
    """
    Attributes:
     - openstack_id: Id of the server.

    """


    def __init__(self, openstack_id=None,):
        self.openstack_id = openstack_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.openstack_id = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('stop_server_args')
        if self.openstack_id is not None:
            oprot.writeFieldBegin('openstack_id', TType.STRING, 1)
            oprot.writeString(self.openstack_id.encode('utf-8') if sys.version_info[0] == 2 else self.openstack_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(stop_server_args)
stop_server_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'openstack_id', 'UTF8', None, ),  # 1
)


class stop_server_result(object):
    """
    Attributes:
     - success
     - e
     - c

    """


    def __init__(self, success=None, e=None, c=None,):
        self.success = success
        self.e = e
        self.c = c

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = serverNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.c = conflictException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('stop_server_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        if self.c is not None:
            oprot.writeFieldBegin('c', TType.STRUCT, 2)
            self.c.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(stop_server_result)
stop_server_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [serverNotFoundException, None], None, ),  # 1
    (2, TType.STRUCT, 'c', [conflictException, None], None, ),  # 2
)


class create_snapshot_args(object):
    """
    Attributes:
     - openstack_id: Id of the server
     - name: Name of new Snapshot
     - elixir_id: Elixir-Id of the user who requested creation of Snapshot
     - base_tags: Tags with which the servers image is also tagged ( for connection information at the webapp)
     - description: Description of the new snapshot

    """


    def __init__(self, openstack_id=None, name=None, elixir_id=None, base_tags=None, description=None,):
        self.openstack_id = openstack_id
        self.name = name
        self.elixir_id = elixir_id
        self.base_tags = base_tags
        self.description = description

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.openstack_id = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.elixir_id = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.base_tags = []
                    (_etype404, _size401) = iprot.readListBegin()
                    for _i405 in range(_size401):
                        _elem406 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.base_tags.append(_elem406)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.description = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_snapshot_args')
        if self.openstack_id is not None:
            oprot.writeFieldBegin('openstack_id', TType.STRING, 1)
            oprot.writeString(self.openstack_id.encode('utf-8') if sys.version_info[0] == 2 else self.openstack_id)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 2)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.elixir_id is not None:
            oprot.writeFieldBegin('elixir_id', TType.STRING, 3)
            oprot.writeString(self.elixir_id.encode('utf-8') if sys.version_info[0] == 2 else self.elixir_id)
            oprot.writeFieldEnd()
        if self.base_tags is not None:
            oprot.writeFieldBegin('base_tags', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.base_tags))
            for iter407 in self.base_tags:
                oprot.writeString(iter407.encode('utf-8') if sys.version_info[0] == 2 else iter407)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.description is not None:
            oprot.writeFieldBegin('description', TType.STRING, 5)
            oprot.writeString(self.description.encode('utf-8') if sys.version_info[0] == 2 else self.description)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_snapshot_args)
create_snapshot_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'openstack_id', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'name', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'elixir_id', 'UTF8', None, ),  # 3
    (4, TType.LIST, 'base_tags', (TType.STRING, 'UTF8', False), None, ),  # 4
    (5, TType.STRING, 'description', 'UTF8', None, ),  # 5
)


class create_snapshot_result(object):
    """
    Attributes:
     - success
     - e
     - c

    """


    def __init__(self, success=None, e=None, c=None,):
        self.success = success
        self.e = e
        self.c = c

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = serverNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.c = conflictException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_snapshot_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        if self.c is not None:
            oprot.writeFieldBegin('c', TType.STRUCT, 2)
            self.c.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_snapshot_result)
create_snapshot_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'e', [serverNotFoundException, None], None, ),  # 1
    (2, TType.STRUCT, 'c', [conflictException, None], None, ),  # 2
)


class get_limits_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_limits_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_limits_args)
get_limits_args.thrift_spec = (
)


class get_limits_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype409, _vtype410, _size408) = iprot.readMapBegin()
                    for _i412 in range(_size408):
                        _key413 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val414 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success[_key413] = _val414
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_limits_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for kiter415, viter416 in self.success.items():
                oprot.writeString(kiter415.encode('utf-8') if sys.version_info[0] == 2 else kiter415)
                oprot.writeString(viter416.encode('utf-8') if sys.version_info[0] == 2 else viter416)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_limits_result)
get_limits_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 0
)


class start_cluster_args(object):
    """
    Attributes:
     - public_key
     - master_instance
     - worker_instance
     - user

    """


    def __init__(self, public_key=None, master_instance=None, worker_instance=None, user=None,):
        self.public_key = public_key
        self.master_instance = master_instance
        self.worker_instance = worker_instance
        self.user = user

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.public_key = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.master_instance = ClusterInstance()
                    self.master_instance.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.worker_instance = []
                    (_etype420, _size417) = iprot.readListBegin()
                    for _i421 in range(_size417):
                        _elem422 = ClusterInstance()
                        _elem422.read(iprot)
                        self.worker_instance.append(_elem422)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.user = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('start_cluster_args')
        if self.public_key is not None:
            oprot.writeFieldBegin('public_key', TType.STRING, 1)
            oprot.writeString(self.public_key.encode('utf-8') if sys.version_info[0] == 2 else self.public_key)
            oprot.writeFieldEnd()
        if self.master_instance is not None:
            oprot.writeFieldBegin('master_instance', TType.STRUCT, 2)
            self.master_instance.write(oprot)
            oprot.writeFieldEnd()
        if self.worker_instance is not None:
            oprot.writeFieldBegin('worker_instance', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.worker_instance))
            for iter423 in self.worker_instance:
                iter423.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.user is not None:
            oprot.writeFieldBegin('user', TType.STRING, 4)
            oprot.writeString(self.user.encode('utf-8') if sys.version_info[0] == 2 else self.user)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(start_cluster_args)
start_cluster_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'public_key', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'master_instance', [ClusterInstance, None], None, ),  # 2
    (3, TType.LIST, 'worker_instance', (TType.STRUCT, [ClusterInstance, None], False), None, ),  # 3
    (4, TType.STRING, 'user', 'UTF8', None, ),  # 4
)


class start_cluster_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype425, _vtype426, _size424) = iprot.readMapBegin()
                    for _i428 in range(_size424):
                        _key429 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val430 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success[_key429] = _val430
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('start_cluster_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for kiter431, viter432 in self.success.items():
                oprot.writeString(kiter431.encode('utf-8') if sys.version_info[0] == 2 else kiter431)
                oprot.writeString(viter432.encode('utf-8') if sys.version_info[0] == 2 else viter432)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(start_cluster_result)
start_cluster_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 0
)


class terminate_cluster_args(object):
    """
    Attributes:
     - cluster_id

    """


    def __init__(self, cluster_id=None,):
        self.cluster_id = cluster_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.cluster_id = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('terminate_cluster_args')
        if self.cluster_id is not None:
            oprot.writeFieldBegin('cluster_id', TType.STRING, 1)
            oprot.writeString(self.cluster_id.encode('utf-8') if sys.version_info[0] == 2 else self.cluster_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(terminate_cluster_args)
terminate_cluster_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'cluster_id', 'UTF8', None, ),  # 1
)


class terminate_cluster_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype434, _vtype435, _size433) = iprot.readMapBegin()
                    for _i437 in range(_size433):
                        _key438 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val439 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success[_key438] = _val439
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('terminate_cluster_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for kiter440, viter441 in self.success.items():
                oprot.writeString(kiter440.encode('utf-8') if sys.version_info[0] == 2 else kiter440)
                oprot.writeString(viter441.encode('utf-8') if sys.version_info[0] == 2 else viter441)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(terminate_cluster_result)
terminate_cluster_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 0
)


class delete_image_args(object):
    """
    Attributes:
     - image_id: Id of image

    """


    def __init__(self, image_id=None,):
        self.image_id = image_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.image_id = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('delete_image_args')
        if self.image_id is not None:
            oprot.writeFieldBegin('image_id', TType.STRING, 1)
            oprot.writeString(self.image_id.encode('utf-8') if sys.version_info[0] == 2 else self.image_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(delete_image_args)
delete_image_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'image_id', 'UTF8', None, ),  # 1
)


class delete_image_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = imageNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('delete_image_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(delete_image_result)
delete_image_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [imageNotFoundException, None], None, ),  # 1
)


class delete_volume_attachment_args(object):
    """
    Attributes:
     - volume_id: Id of the attached volume
     - server_id: Id of the server where the volume is attached

    """


    def __init__(self, volume_id=None, server_id=None,):
        self.volume_id = volume_id
        self.server_id = server_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.volume_id = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.server_id = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('delete_volume_attachment_args')
        if self.volume_id is not None:
            oprot.writeFieldBegin('volume_id', TType.STRING, 1)
            oprot.writeString(self.volume_id.encode('utf-8') if sys.version_info[0] == 2 else self.volume_id)
            oprot.writeFieldEnd()
        if self.server_id is not None:
            oprot.writeFieldBegin('server_id', TType.STRING, 2)
            oprot.writeString(self.server_id.encode('utf-8') if sys.version_info[0] == 2 else self.server_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(delete_volume_attachment_args)
delete_volume_attachment_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'volume_id', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'server_id', 'UTF8', None, ),  # 2
)


class delete_volume_attachment_result(object):
    """
    Attributes:
     - success
     - e
     - c

    """


    def __init__(self, success=None, e=None, c=None,):
        self.success = success
        self.e = e
        self.c = c

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = serverNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.c = conflictException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('delete_volume_attachment_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        if self.c is not None:
            oprot.writeFieldBegin('c', TType.STRUCT, 2)
            self.c.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(delete_volume_attachment_result)
delete_volume_attachment_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [serverNotFoundException, None], None, ),  # 1
    (2, TType.STRUCT, 'c', [conflictException, None], None, ),  # 2
)


class delete_volume_args(object):
    """
    Attributes:
     - volume_id

    """


    def __init__(self, volume_id=None,):
        self.volume_id = volume_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.volume_id = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('delete_volume_args')
        if self.volume_id is not None:
            oprot.writeFieldBegin('volume_id', TType.STRING, 1)
            oprot.writeString(self.volume_id.encode('utf-8') if sys.version_info[0] == 2 else self.volume_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(delete_volume_args)
delete_volume_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'volume_id', 'UTF8', None, ),  # 1
)


class delete_volume_result(object):
    """
    Attributes:
     - success
     - c

    """


    def __init__(self, success=None, c=None,):
        self.success = success
        self.c = c

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.c = conflictException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('delete_volume_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.c is not None:
            oprot.writeFieldBegin('c', TType.STRUCT, 1)
            self.c.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(delete_volume_result)
delete_volume_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'c', [conflictException, None], None, ),  # 1
)


class attach_volume_to_server_args(object):
    """
    Attributes:
     - openstack_id: Id of server
     - volume_id: Id of volume

    """


    def __init__(self, openstack_id=None, volume_id=None,):
        self.openstack_id = openstack_id
        self.volume_id = volume_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.openstack_id = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.volume_id = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('attach_volume_to_server_args')
        if self.openstack_id is not None:
            oprot.writeFieldBegin('openstack_id', TType.STRING, 1)
            oprot.writeString(self.openstack_id.encode('utf-8') if sys.version_info[0] == 2 else self.openstack_id)
            oprot.writeFieldEnd()
        if self.volume_id is not None:
            oprot.writeFieldBegin('volume_id', TType.STRING, 2)
            oprot.writeString(self.volume_id.encode('utf-8') if sys.version_info[0] == 2 else self.volume_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(attach_volume_to_server_args)
attach_volume_to_server_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'openstack_id', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'volume_id', 'UTF8', None, ),  # 2
)


class attach_volume_to_server_result(object):
    """
    Attributes:
     - success
     - e
     - c

    """


    def __init__(self, success=None, e=None, c=None,):
        self.success = success
        self.e = e
        self.c = c

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype443, _vtype444, _size442) = iprot.readMapBegin()
                    for _i446 in range(_size442):
                        _key447 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val448 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success[_key447] = _val448
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = serverNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.c = conflictException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('attach_volume_to_server_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for kiter449, viter450 in self.success.items():
                oprot.writeString(kiter449.encode('utf-8') if sys.version_info[0] == 2 else kiter449)
                oprot.writeString(viter450.encode('utf-8') if sys.version_info[0] == 2 else viter450)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        if self.c is not None:
            oprot.writeFieldBegin('c', TType.STRUCT, 2)
            self.c.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(attach_volume_to_server_result)
attach_volume_to_server_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'e', [serverNotFoundException, None], None, ),  # 1
    (2, TType.STRUCT, 'c', [conflictException, None], None, ),  # 2
)


class check_server_status_args(object):
    """
    Attributes:
     - openstack_id: Id of the server

    """


    def __init__(self, openstack_id=None,):
        self.openstack_id = openstack_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.openstack_id = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('check_server_status_args')
        if self.openstack_id is not None:
            oprot.writeFieldBegin('openstack_id', TType.STRING, 1)
            oprot.writeString(self.openstack_id.encode('utf-8') if sys.version_info[0] == 2 else self.openstack_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(check_server_status_args)
check_server_status_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'openstack_id', 'UTF8', None, ),  # 1
)


class check_server_status_result(object):
    """
    Attributes:
     - success
     - e
     - r

    """


    def __init__(self, success=None, e=None, r=None,):
        self.success = success
        self.e = e
        self.r = r

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = VM()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = serverNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.r = ressourceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('check_server_status_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        if self.r is not None:
            oprot.writeFieldBegin('r', TType.STRUCT, 2)
            self.r.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(check_server_status_result)
check_server_status_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [VM, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [serverNotFoundException, None], None, ),  # 1
    (2, TType.STRUCT, 'r', [ressourceException, None], None, ),  # 2
)


class resume_server_args(object):
    """
    Attributes:
     - openstack_id: Id of the server

    """


    def __init__(self, openstack_id=None,):
        self.openstack_id = openstack_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.openstack_id = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('resume_server_args')
        if self.openstack_id is not None:
            oprot.writeFieldBegin('openstack_id', TType.STRING, 1)
            oprot.writeString(self.openstack_id.encode('utf-8') if sys.version_info[0] == 2 else self.openstack_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(resume_server_args)
resume_server_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'openstack_id', 'UTF8', None, ),  # 1
)


class resume_server_result(object):
    """
    Attributes:
     - success
     - e
     - c

    """


    def __init__(self, success=None, e=None, c=None,):
        self.success = success
        self.e = e
        self.c = c

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = serverNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.c = conflictException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('resume_server_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        if self.c is not None:
            oprot.writeFieldBegin('c', TType.STRUCT, 2)
            self.c.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(resume_server_result)
resume_server_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [serverNotFoundException, None], None, ),  # 1
    (2, TType.STRUCT, 'c', [conflictException, None], None, ),  # 2
)


class create_volume_args(object):
    """
    Attributes:
     - volume_name: Name of volume
     - volume_storage: Diskspace in GB for new volume
     - metadata: Metadata for the new volume

    """


    def __init__(self, volume_name=None, volume_storage=None, metadata=None,):
        self.volume_name = volume_name
        self.volume_storage = volume_storage
        self.metadata = metadata

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.volume_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.volume_storage = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.metadata = {}
                    (_ktype452, _vtype453, _size451) = iprot.readMapBegin()
                    for _i455 in range(_size451):
                        _key456 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val457 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.metadata[_key456] = _val457
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_volume_args')
        if self.volume_name is not None:
            oprot.writeFieldBegin('volume_name', TType.STRING, 1)
            oprot.writeString(self.volume_name.encode('utf-8') if sys.version_info[0] == 2 else self.volume_name)
            oprot.writeFieldEnd()
        if self.volume_storage is not None:
            oprot.writeFieldBegin('volume_storage', TType.I32, 2)
            oprot.writeI32(self.volume_storage)
            oprot.writeFieldEnd()
        if self.metadata is not None:
            oprot.writeFieldBegin('metadata', TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.metadata))
            for kiter458, viter459 in self.metadata.items():
                oprot.writeString(kiter458.encode('utf-8') if sys.version_info[0] == 2 else kiter458)
                oprot.writeString(viter459.encode('utf-8') if sys.version_info[0] == 2 else viter459)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_volume_args)
create_volume_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'volume_name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'volume_storage', None, None, ),  # 2
    (3, TType.MAP, 'metadata', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 3
)


class create_volume_result(object):
    """
    Attributes:
     - success
     - r

    """


    def __init__(self, success=None, r=None,):
        self.success = success
        self.r = r

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype461, _vtype462, _size460) = iprot.readMapBegin()
                    for _i464 in range(_size460):
                        _key465 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val466 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success[_key465] = _val466
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.r = ressourceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_volume_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for kiter467, viter468 in self.success.items():
                oprot.writeString(kiter467.encode('utf-8') if sys.version_info[0] == 2 else kiter467)
                oprot.writeString(viter468.encode('utf-8') if sys.version_info[0] == 2 else viter468)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.r is not None:
            oprot.writeFieldBegin('r', TType.STRUCT, 1)
            self.r.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_volume_result)
create_volume_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'r', [ressourceException, None], None, ),  # 1
)


class reboot_server_args(object):
    """
    Attributes:
     - openstack_id: Id of the server
     - reboot_type: HARD or SOFT

    """


    def __init__(self, openstack_id=None, reboot_type=None,):
        self.openstack_id = openstack_id
        self.reboot_type = reboot_type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.openstack_id = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.reboot_type = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('reboot_server_args')
        if self.openstack_id is not None:
            oprot.writeFieldBegin('openstack_id', TType.STRING, 1)
            oprot.writeString(self.openstack_id.encode('utf-8') if sys.version_info[0] == 2 else self.openstack_id)
            oprot.writeFieldEnd()
        if self.reboot_type is not None:
            oprot.writeFieldBegin('reboot_type', TType.STRING, 2)
            oprot.writeString(self.reboot_type.encode('utf-8') if sys.version_info[0] == 2 else self.reboot_type)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(reboot_server_args)
reboot_server_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'openstack_id', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'reboot_type', 'UTF8', None, ),  # 2
)


class reboot_server_result(object):
    """
    Attributes:
     - success
     - e
     - c

    """


    def __init__(self, success=None, e=None, c=None,):
        self.success = success
        self.e = e
        self.c = c

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = serverNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.c = conflictException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('reboot_server_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        if self.c is not None:
            oprot.writeFieldBegin('c', TType.STRUCT, 2)
            self.c.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(reboot_server_result)
reboot_server_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [serverNotFoundException, None], None, ),  # 1
    (2, TType.STRUCT, 'c', [conflictException, None], None, ),  # 2
)
fix_spec(all_structs)
del all_structs
