#
# Autogenerated by Thrift Compiler (0.12.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import (
    TType,
    TMessageType,
    TFrozenDict,
    TException,
    TApplicationException,
)
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import logging
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport

all_structs = []


class Iface(object):
    """
    This VirtualMachiine service deploys methods for creating,deleting,stopping etc. VirtualMachines in Openstack.

    """

    def check_Version(self, version):
        """
        Parameters:
         - version

        """
        pass

    def get_client_version(self):
        """
        Get Client version.
        Returns Version of the client

        """
        pass

    def get_gateway_ip(self):
        """
        Gets the gateway ip.

        """
        pass

    def get_calculation_formulars(self):
        pass

    def import_keypair(self, keyname, public_key):
        """
        Import Key to openstack.
        Returns : keypair

        Parameters:
         - keyname: Name for the keypair
         - public_key: The public key

        """
        pass

    def get_vm_ports(self, openstack_id):
        """
        Get Ip and Port of server
        Returns:  {'IP': ip, 'PORT': port,'UDP':udp}

        Parameters:
         - openstack_id: Id of server

        """
        pass

    def get_Flavors(self):
        """
        Get Flavors.
        Returns: List of flavor instances.

        """
        pass

    def get_Images(self):
        """
        Get Images.
        Returns: List of Image instances.

        """
        pass

    def get_Image_with_Tag(self, openstack_id):
        """
        Get an image with tag.
        Returns: Image with tag.

        Parameters:
         - openstack_id

        """
        pass

    def get_Images_by_filter(self, filter_json):
        """
        Get Images and filter by list of strings.
        Returns: List of Image instances.

        Parameters:
         - filter_json

        """
        pass

    def get_volume(self, volume_id):
        """
        Parameters:
         - volume_id

        """
        pass

    def get_volumes_by_ids(self, volume_ids):
        """
        Parameters:
         - volume_ids

        """
        pass

    def delete_server(self, openstack_id):
        """
        Delete server.
        Returns: True if deleted, False if not

        Parameters:
         - openstack_id: Id of the server.

        """
        pass

    def add_metadata_to_server(self, servername, metadata):
        """
        Parameters:
         - servername
         - metadata

        """
        pass

    def delete_metadata_from_server(self, servername, keys):
        """
        Parameters:
         - servername
         - keys

        """
        pass

    def add_floating_ip_to_server(self, openstack_id, network):
        """
        Add floating ip to server.
        Returns: the floating ip

        Parameters:
         - openstack_id: Id of the server
         - network: Network name of the network which provides the floating Ip.

        """
        pass

    def create_connection(
        self, username, password, auth_url, user_domain_name, project_domain_name
    ):
        """
        Create connection to OpenStack.
        Connection instance

        Parameters:
         - username: Name of the OpenStack user.
         - password: Password of the OpenStack user
         - auth_url: Auth Url from OpenStack
         - user_domain_name: Name of the project from the OpenStack user.
        4:string project_name,

        /** Domain name of OpenStack
         - project_domain_name: Project domain name of OpenStack

        """
        pass

    def start_server(
        self,
        flavor,
        image,
        public_key,
        servername,
        metadata,
        diskspace,
        volumename,
        https,
        http,
        resenv,
    ):
        """
        Start a new server.

        Parameters:
         - flavor: Name of the  Flavor to use.
         - image: Name of the image to use.
         - public_key: Public Key to use
         - servername: Name for the new server
         - metadata: Metadata for the new instance
         - diskspace: Diskspace in GB for additional volume.
         - volumename: Name of additional Volume
         - https
         - http
         - resenv

        """
        pass

    def start_server_with_custom_key(
        self,
        flavor,
        image,
        servername,
        metadata,
        diskspace,
        volumename,
        http,
        https,
        resenv,
    ):
        """
        Start a new server with custom key for ansible.

        Parameters:
         - flavor: Name of the  Flavor to use.
         - image: Name of the image to use.
         - servername: Name for the new server
         - metadata: Metadata for the new instance
         - diskspace: Diskspace in GB for additional volume.
         - volumename: Name of additional Volume
         - http: Boolean for http security rule
         - https: Boolean for https security rule
         - resenv

        """
        pass

    def exist_server(self, name):
        """
        Check if there is an instance with name

        Parameters:
         - name

        """
        pass

    def create_and_deploy_playbook(
        self, public_key, playbooks_information, openstack_id
    ):
        """
        Create and deploy an anaconda ansible playbook

        Parameters:
         - public_key
         - playbooks_information
         - openstack_id

        """
        pass

    def get_playbook_logs(self, openstack_id):
        """
        Get the logs from a playbook run

        Parameters:
         - openstack_id

        """
        pass

    def has_forc(self):
        """
        Get boolean if client has backend url configured

        """
        pass

    def get_forc_url(self):
        pass

    def create_backend(self, elixir_id, user_key_url, template, upstream_url):
        """
        Create a backend

        Parameters:
         - elixir_id
         - user_key_url
         - template
         - upstream_url

        """
        pass

    def get_backends(self):
        """
        Get all backends

        """
        pass

    def get_backends_by_owner(self, elixir_id):
        """
        Get all backends by owner

        Parameters:
         - elixir_id

        """
        pass

    def get_backends_by_template(self, template):
        """
        Get all backends by template

        Parameters:
         - template

        """
        pass

    def get_backend_by_id(self, id):
        """
        Get a backend by id

        Parameters:
         - id

        """
        pass

    def delete_backend(self, id):
        """
        Delete a backend

        Parameters:
         - id

        """
        pass

    def get_templates(self):
        pass

    def get_allowed_templates(self):
        pass

    def get_templates_by_template(self, template_name):
        """
        Parameters:
         - template_name

        """
        pass

    def check_template(self, template_name, template_version):
        """
        Parameters:
         - template_name
         - template_version

        """
        pass

    def add_udp_security_group(self, server_id):
        """
        Adds a security group to a server

        Parameters:
         - server_id: OpenStack id of the server

        """
        pass

    def get_servers(self):
        """
        Get all servers.
        Returns: List of server instances.

        """
        pass

    def get_servers_by_ids(self, server_ids):
        """
        * Get list of servers by ids
           *

        Parameters:
         - server_ids

        """
        pass

    def get_servers_by_bibigrid_id(self, bibigrid_id):
        """
        * Get servers by bibigrid cluster id.
           *

        Parameters:
         - bibigrid_id

        """
        pass

    def get_cluster_info(self, cluster_id):
        """
        Parameters:
         - cluster_id

        """
        pass

    def get_server(self, openstack_id):
        """
        Get a Server.
        Returns: A server instance.

        Parameters:
         - openstack_id: Id of the server.

        """
        pass

    def stop_server(self, openstack_id):
        """
        Stop a Server.
        Returns: True if stopped, False if not.

        Parameters:
         - openstack_id: Id of the server.

        """
        pass

    def create_snapshot(self, openstack_id, name, elixir_id, base_tags, description):
        """
        Create Snapshot.
        Returns: Id of new Snapshot


        Parameters:
         - openstack_id: Id of the server
         - name: Name of new Snapshot
         - elixir_id: Elixir-Id of the user who requested creation of Snapshot
         - base_tags: Tags with which the servers image is also tagged ( for connection information at the webapp)
         - description: Description of the new snapshot

        """
        pass

    def get_limits(self):
        """
        Get Limits of OpenStack Projekt from client.
        Returns: {'maxTotalVolumes': maxTotalVolumes, 'maxTotalVolumeGigabytes': maxTotalVolumeGigabytes,
                  'maxTotalInstances': maxTotalInstances, 'totalRamUsed': totalRamUsed,
                 'totalInstancesUsed': totalInstancesUsed}

        """
        pass

    def start_cluster(self, public_key, master_instance, worker_instance, user):
        """
        Parameters:
         - public_key
         - master_instance
         - worker_instance
         - user

        """
        pass

    def terminate_cluster(self, cluster_id):
        """
        Parameters:
         - cluster_id

        """
        pass

    def delete_image(self, image_id):
        """
        Delete Image.
        Return: True if deleted, False if not

        Parameters:
         - image_id: Id of image

        """
        pass

    def delete_volume_attachment(self, volume_id, server_id):
        """
        Delete volume attachment
        Return: True if deleted, False if not

        Parameters:
         - volume_id: Id of the attached volume
         - server_id: Id of the server where the volume is attached

        """
        pass

    def delete_volume(self, volume_id):
        """
        Delete volume.
        Returns:  True if deleted, False if not

        Parameters:
         - volume_id

        """
        pass

    def attach_volume_to_server(self, openstack_id, volume_id):
        """
        Attach volume to server.
        Returns:  True if attached, False if not

        Parameters:
         - openstack_id: Id of server
         - volume_id: Id of volume

        """
        pass

    def check_server_status(self, openstack_id, diskspace, volume_id):
        """
        Check status of server.
        Returns: server instance

        Parameters:
         - openstack_id: Id of the server
         - diskspace: diskspace of server(volume will be attached if server is active and diskpace >0)
         - volume_id: Id of the volume

        """
        pass

    def setUserPassword(self, user, password):
        """
        Set Password of a User
        Returns: the new password

        Parameters:
         - user: Elixir-Id of the user which wants to set a password
         - password: New password

        """
        pass

    def resume_server(self, openstack_id):
        """
        Resume Server.
        Returns: True if resumed False if not

        Parameters:
         - openstack_id: Id of the server

        """
        pass

    def create_volume(self, volume_name, diskspace, metadata):
        """
        Create volume.
        Returns: Id of new volume

        Parameters:
         - volume_name: Name of volume
         - diskspace: Diskspace in GB for new volume
         - metadata: Metadata for the new volume

        """
        pass

    def reboot_server(self, server_id, reboot_type):
        """
        Reboot server.
        Returns: True if rebooted False if not

        Parameters:
         - server_id: Id of the server
         - reboot_type: HARD or SOFT

        """
        pass


class Client(Iface):
    """
    This VirtualMachiine service deploys methods for creating,deleting,stopping etc. VirtualMachines in Openstack.

    """

    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def check_Version(self, version):
        """
        Parameters:
         - version

        """
        self.send_check_Version(version)
        return self.recv_check_Version()

    def send_check_Version(self, version):
        self._oprot.writeMessageBegin("check_Version", TMessageType.CALL, self._seqid)
        args = check_Version_args()
        args.version = version
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_check_Version(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = check_Version_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "check_Version failed: unknown result"
        )

    def get_client_version(self):
        """
        Get Client version.
        Returns Version of the client

        """
        self.send_get_client_version()
        return self.recv_get_client_version()

    def send_get_client_version(self):
        self._oprot.writeMessageBegin(
            "get_client_version", TMessageType.CALL, self._seqid
        )
        args = get_client_version_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_client_version(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_client_version_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "get_client_version failed: unknown result",
        )

    def get_gateway_ip(self):
        """
        Gets the gateway ip.

        """
        self.send_get_gateway_ip()
        return self.recv_get_gateway_ip()

    def send_get_gateway_ip(self):
        self._oprot.writeMessageBegin("get_gateway_ip", TMessageType.CALL, self._seqid)
        args = get_gateway_ip_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_gateway_ip(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_gateway_ip_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "get_gateway_ip failed: unknown result",
        )

    def get_calculation_formulars(self):
        self.send_get_calculation_formulars()
        return self.recv_get_calculation_formulars()

    def send_get_calculation_formulars(self):
        self._oprot.writeMessageBegin(
            "get_calculation_formulars", TMessageType.CALL, self._seqid
        )
        args = get_calculation_formulars_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_calculation_formulars(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_calculation_formulars_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "get_calculation_formulars failed: unknown result",
        )

    def import_keypair(self, keyname, public_key):
        """
        Import Key to openstack.
        Returns : keypair

        Parameters:
         - keyname: Name for the keypair
         - public_key: The public key

        """
        self.send_import_keypair(keyname, public_key)
        return self.recv_import_keypair()

    def send_import_keypair(self, keyname, public_key):
        self._oprot.writeMessageBegin("import_keypair", TMessageType.CALL, self._seqid)
        args = import_keypair_args()
        args.keyname = keyname
        args.public_key = public_key
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_import_keypair(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = import_keypair_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "import_keypair failed: unknown result",
        )

    def get_vm_ports(self, openstack_id):
        """
        Get Ip and Port of server
        Returns:  {'IP': ip, 'PORT': port,'UDP':udp}

        Parameters:
         - openstack_id: Id of server

        """
        self.send_get_vm_ports(openstack_id)
        return self.recv_get_vm_ports()

    def send_get_vm_ports(self, openstack_id):
        self._oprot.writeMessageBegin("get_vm_ports", TMessageType.CALL, self._seqid)
        args = get_vm_ports_args()
        args.openstack_id = openstack_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_vm_ports(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_vm_ports_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "get_vm_ports failed: unknown result"
        )

    def get_Flavors(self):
        """
        Get Flavors.
        Returns: List of flavor instances.

        """
        self.send_get_Flavors()
        return self.recv_get_Flavors()

    def send_get_Flavors(self):
        self._oprot.writeMessageBegin("get_Flavors", TMessageType.CALL, self._seqid)
        args = get_Flavors_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_Flavors(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_Flavors_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "get_Flavors failed: unknown result"
        )

    def get_Images(self):
        """
        Get Images.
        Returns: List of Image instances.

        """
        self.send_get_Images()
        return self.recv_get_Images()

    def send_get_Images(self):
        self._oprot.writeMessageBegin("get_Images", TMessageType.CALL, self._seqid)
        args = get_Images_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_Images(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_Images_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "get_Images failed: unknown result"
        )

    def get_Image_with_Tag(self, openstack_id):
        """
        Get an image with tag.
        Returns: Image with tag.

        Parameters:
         - openstack_id

        """
        self.send_get_Image_with_Tag(openstack_id)
        return self.recv_get_Image_with_Tag()

    def send_get_Image_with_Tag(self, openstack_id):
        self._oprot.writeMessageBegin(
            "get_Image_with_Tag", TMessageType.CALL, self._seqid
        )
        args = get_Image_with_Tag_args()
        args.openstack_id = openstack_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_Image_with_Tag(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_Image_with_Tag_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "get_Image_with_Tag failed: unknown result",
        )

    def get_Images_by_filter(self, filter_json):
        """
        Get Images and filter by list of strings.
        Returns: List of Image instances.

        Parameters:
         - filter_json

        """
        self.send_get_Images_by_filter(filter_json)
        return self.recv_get_Images_by_filter()

    def send_get_Images_by_filter(self, filter_json):
        self._oprot.writeMessageBegin(
            "get_Images_by_filter", TMessageType.CALL, self._seqid
        )
        args = get_Images_by_filter_args()
        args.filter_json = filter_json
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_Images_by_filter(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_Images_by_filter_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "get_Images_by_filter failed: unknown result",
        )

    def get_volume(self, volume_id):
        """
        Parameters:
         - volume_id

        """
        self.send_get_volume(volume_id)
        return self.recv_get_volume()

    def send_get_volume(self, volume_id):
        self._oprot.writeMessageBegin("get_volume", TMessageType.CALL, self._seqid)
        args = get_volume_args()
        args.volume_id = volume_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_volume(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_volume_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "get_volume failed: unknown result"
        )

    def get_volumes_by_ids(self, volume_ids):
        """
        Parameters:
         - volume_ids

        """
        self.send_get_volumes_by_ids(volume_ids)
        return self.recv_get_volumes_by_ids()

    def send_get_volumes_by_ids(self, volume_ids):
        self._oprot.writeMessageBegin(
            "get_volumes_by_ids", TMessageType.CALL, self._seqid
        )
        args = get_volumes_by_ids_args()
        args.volume_ids = volume_ids
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_volumes_by_ids(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_volumes_by_ids_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "get_volumes_by_ids failed: unknown result",
        )

    def delete_server(self, openstack_id):
        """
        Delete server.
        Returns: True if deleted, False if not

        Parameters:
         - openstack_id: Id of the server.

        """
        self.send_delete_server(openstack_id)
        return self.recv_delete_server()

    def send_delete_server(self, openstack_id):
        self._oprot.writeMessageBegin("delete_server", TMessageType.CALL, self._seqid)
        args = delete_server_args()
        args.openstack_id = openstack_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_delete_server(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = delete_server_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "delete_server failed: unknown result"
        )

    def add_metadata_to_server(self, servername, metadata):
        """
        Parameters:
         - servername
         - metadata

        """
        self.send_add_metadata_to_server(servername, metadata)
        return self.recv_add_metadata_to_server()

    def send_add_metadata_to_server(self, servername, metadata):
        self._oprot.writeMessageBegin(
            "add_metadata_to_server", TMessageType.CALL, self._seqid
        )
        args = add_metadata_to_server_args()
        args.servername = servername
        args.metadata = metadata
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_metadata_to_server(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_metadata_to_server_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "add_metadata_to_server failed: unknown result",
        )

    def delete_metadata_from_server(self, servername, keys):
        """
        Parameters:
         - servername
         - keys

        """
        self.send_delete_metadata_from_server(servername, keys)
        return self.recv_delete_metadata_from_server()

    def send_delete_metadata_from_server(self, servername, keys):
        self._oprot.writeMessageBegin(
            "delete_metadata_from_server", TMessageType.CALL, self._seqid
        )
        args = delete_metadata_from_server_args()
        args.servername = servername
        args.keys = keys
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_delete_metadata_from_server(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = delete_metadata_from_server_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "delete_metadata_from_server failed: unknown result",
        )

    def add_floating_ip_to_server(self, openstack_id, network):
        """
        Add floating ip to server.
        Returns: the floating ip

        Parameters:
         - openstack_id: Id of the server
         - network: Network name of the network which provides the floating Ip.

        """
        self.send_add_floating_ip_to_server(openstack_id, network)
        return self.recv_add_floating_ip_to_server()

    def send_add_floating_ip_to_server(self, openstack_id, network):
        self._oprot.writeMessageBegin(
            "add_floating_ip_to_server", TMessageType.CALL, self._seqid
        )
        args = add_floating_ip_to_server_args()
        args.openstack_id = openstack_id
        args.network = network
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_floating_ip_to_server(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_floating_ip_to_server_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        if result.f is not None:
            raise result.f
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "add_floating_ip_to_server failed: unknown result",
        )

    def create_connection(
        self, username, password, auth_url, user_domain_name, project_domain_name
    ):
        """
        Create connection to OpenStack.
        Connection instance

        Parameters:
         - username: Name of the OpenStack user.
         - password: Password of the OpenStack user
         - auth_url: Auth Url from OpenStack
         - user_domain_name: Name of the project from the OpenStack user.
        4:string project_name,

        /** Domain name of OpenStack
         - project_domain_name: Project domain name of OpenStack

        """
        self.send_create_connection(
            username, password, auth_url, user_domain_name, project_domain_name
        )
        return self.recv_create_connection()

    def send_create_connection(
        self, username, password, auth_url, user_domain_name, project_domain_name
    ):
        self._oprot.writeMessageBegin(
            "create_connection", TMessageType.CALL, self._seqid
        )
        args = create_connection_args()
        args.username = username
        args.password = password
        args.auth_url = auth_url
        args.user_domain_name = user_domain_name
        args.project_domain_name = project_domain_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_connection(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_connection_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "create_connection failed: unknown result",
        )

    def start_server(
        self,
        flavor,
        image,
        public_key,
        servername,
        metadata,
        diskspace,
        volumename,
        https,
        http,
        resenv,
    ):
        """
        Start a new server.

        Parameters:
         - flavor: Name of the  Flavor to use.
         - image: Name of the image to use.
         - public_key: Public Key to use
         - servername: Name for the new server
         - metadata: Metadata for the new instance
         - diskspace: Diskspace in GB for additional volume.
         - volumename: Name of additional Volume
         - https
         - http
         - resenv

        """
        self.send_start_server(
            flavor,
            image,
            public_key,
            servername,
            metadata,
            diskspace,
            volumename,
            https,
            http,
            resenv,
        )
        return self.recv_start_server()

    def send_start_server(
        self,
        flavor,
        image,
        public_key,
        servername,
        metadata,
        diskspace,
        volumename,
        https,
        http,
        resenv,
    ):
        self._oprot.writeMessageBegin("start_server", TMessageType.CALL, self._seqid)
        args = start_server_args()
        args.flavor = flavor
        args.image = image
        args.public_key = public_key
        args.servername = servername
        args.metadata = metadata
        args.diskspace = diskspace
        args.volumename = volumename
        args.https = https
        args.http = http
        args.resenv = resenv
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_start_server(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = start_server_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        if result.r is not None:
            raise result.r
        if result.s is not None:
            raise result.s
        if result.n is not None:
            raise result.n
        if result.i is not None:
            raise result.i
        if result.f is not None:
            raise result.f
        if result.o is not None:
            raise result.o
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "start_server failed: unknown result"
        )

    def start_server_with_custom_key(
        self,
        flavor,
        image,
        servername,
        metadata,
        diskspace,
        volumename,
        http,
        https,
        resenv,
    ):
        """
        Start a new server with custom key for ansible.

        Parameters:
         - flavor: Name of the  Flavor to use.
         - image: Name of the image to use.
         - servername: Name for the new server
         - metadata: Metadata for the new instance
         - diskspace: Diskspace in GB for additional volume.
         - volumename: Name of additional Volume
         - http: Boolean for http security rule
         - https: Boolean for https security rule
         - resenv

        """
        self.send_start_server_with_custom_key(
            flavor,
            image,
            servername,
            metadata,
            diskspace,
            volumename,
            http,
            https,
            resenv,
        )
        return self.recv_start_server_with_custom_key()

    def send_start_server_with_custom_key(
        self,
        flavor,
        image,
        servername,
        metadata,
        diskspace,
        volumename,
        http,
        https,
        resenv,
    ):
        self._oprot.writeMessageBegin(
            "start_server_with_custom_key", TMessageType.CALL, self._seqid
        )
        args = start_server_with_custom_key_args()
        args.flavor = flavor
        args.image = image
        args.servername = servername
        args.metadata = metadata
        args.diskspace = diskspace
        args.volumename = volumename
        args.http = http
        args.https = https
        args.resenv = resenv
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_start_server_with_custom_key(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = start_server_with_custom_key_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        if result.r is not None:
            raise result.r
        if result.s is not None:
            raise result.s
        if result.n is not None:
            raise result.n
        if result.i is not None:
            raise result.i
        if result.f is not None:
            raise result.f
        if result.o is not None:
            raise result.o
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "start_server_with_custom_key failed: unknown result",
        )

    def exist_server(self, name):
        """
        Check if there is an instance with name

        Parameters:
         - name

        """
        self.send_exist_server(name)
        return self.recv_exist_server()

    def send_exist_server(self, name):
        self._oprot.writeMessageBegin("exist_server", TMessageType.CALL, self._seqid)
        args = exist_server_args()
        args.name = name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_exist_server(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = exist_server_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "exist_server failed: unknown result"
        )

    def create_and_deploy_playbook(
        self, public_key, playbooks_information, openstack_id
    ):
        """
        Create and deploy an anaconda ansible playbook

        Parameters:
         - public_key
         - playbooks_information
         - openstack_id

        """
        self.send_create_and_deploy_playbook(
            public_key, playbooks_information, openstack_id
        )
        return self.recv_create_and_deploy_playbook()

    def send_create_and_deploy_playbook(
        self, public_key, playbooks_information, openstack_id
    ):
        self._oprot.writeMessageBegin(
            "create_and_deploy_playbook", TMessageType.CALL, self._seqid
        )
        args = create_and_deploy_playbook_args()
        args.public_key = public_key
        args.playbooks_information = playbooks_information
        args.openstack_id = openstack_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_and_deploy_playbook(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_and_deploy_playbook_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "create_and_deploy_playbook failed: unknown result",
        )

    def get_playbook_logs(self, openstack_id):
        """
        Get the logs from a playbook run

        Parameters:
         - openstack_id

        """
        self.send_get_playbook_logs(openstack_id)
        return self.recv_get_playbook_logs()

    def send_get_playbook_logs(self, openstack_id):
        self._oprot.writeMessageBegin(
            "get_playbook_logs", TMessageType.CALL, self._seqid
        )
        args = get_playbook_logs_args()
        args.openstack_id = openstack_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_playbook_logs(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_playbook_logs_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "get_playbook_logs failed: unknown result",
        )

    def has_forc(self):
        """
        Get boolean if client has backend url configured

        """
        self.send_has_forc()
        return self.recv_has_forc()

    def send_has_forc(self):
        self._oprot.writeMessageBegin("has_forc", TMessageType.CALL, self._seqid)
        args = has_forc_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_has_forc(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = has_forc_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "has_forc failed: unknown result"
        )

    def get_forc_url(self):
        self.send_get_forc_url()
        return self.recv_get_forc_url()

    def send_get_forc_url(self):
        self._oprot.writeMessageBegin("get_forc_url", TMessageType.CALL, self._seqid)
        args = get_forc_url_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_forc_url(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_forc_url_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "get_forc_url failed: unknown result"
        )

    def create_backend(self, elixir_id, user_key_url, template, upstream_url):
        """
        Create a backend

        Parameters:
         - elixir_id
         - user_key_url
         - template
         - upstream_url

        """
        self.send_create_backend(elixir_id, user_key_url, template, upstream_url)
        return self.recv_create_backend()

    def send_create_backend(self, elixir_id, user_key_url, template, upstream_url):
        self._oprot.writeMessageBegin("create_backend", TMessageType.CALL, self._seqid)
        args = create_backend_args()
        args.elixir_id = elixir_id
        args.user_key_url = user_key_url
        args.template = template
        args.upstream_url = upstream_url
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_backend(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_backend_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "create_backend failed: unknown result",
        )

    def get_backends(self):
        """
        Get all backends

        """
        self.send_get_backends()
        return self.recv_get_backends()

    def send_get_backends(self):
        self._oprot.writeMessageBegin("get_backends", TMessageType.CALL, self._seqid)
        args = get_backends_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_backends(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_backends_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "get_backends failed: unknown result"
        )

    def get_backends_by_owner(self, elixir_id):
        """
        Get all backends by owner

        Parameters:
         - elixir_id

        """
        self.send_get_backends_by_owner(elixir_id)
        return self.recv_get_backends_by_owner()

    def send_get_backends_by_owner(self, elixir_id):
        self._oprot.writeMessageBegin(
            "get_backends_by_owner", TMessageType.CALL, self._seqid
        )
        args = get_backends_by_owner_args()
        args.elixir_id = elixir_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_backends_by_owner(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_backends_by_owner_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "get_backends_by_owner failed: unknown result",
        )

    def get_backends_by_template(self, template):
        """
        Get all backends by template

        Parameters:
         - template

        """
        self.send_get_backends_by_template(template)
        return self.recv_get_backends_by_template()

    def send_get_backends_by_template(self, template):
        self._oprot.writeMessageBegin(
            "get_backends_by_template", TMessageType.CALL, self._seqid
        )
        args = get_backends_by_template_args()
        args.template = template
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_backends_by_template(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_backends_by_template_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "get_backends_by_template failed: unknown result",
        )

    def get_backend_by_id(self, id):
        """
        Get a backend by id

        Parameters:
         - id

        """
        self.send_get_backend_by_id(id)
        return self.recv_get_backend_by_id()

    def send_get_backend_by_id(self, id):
        self._oprot.writeMessageBegin(
            "get_backend_by_id", TMessageType.CALL, self._seqid
        )
        args = get_backend_by_id_args()
        args.id = id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_backend_by_id(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_backend_by_id_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "get_backend_by_id failed: unknown result",
        )

    def delete_backend(self, id):
        """
        Delete a backend

        Parameters:
         - id

        """
        self.send_delete_backend(id)
        return self.recv_delete_backend()

    def send_delete_backend(self, id):
        self._oprot.writeMessageBegin("delete_backend", TMessageType.CALL, self._seqid)
        args = delete_backend_args()
        args.id = id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_delete_backend(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = delete_backend_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "delete_backend failed: unknown result",
        )

    def get_templates(self):
        self.send_get_templates()
        return self.recv_get_templates()

    def send_get_templates(self):
        self._oprot.writeMessageBegin("get_templates", TMessageType.CALL, self._seqid)
        args = get_templates_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_templates(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_templates_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "get_templates failed: unknown result"
        )

    def get_allowed_templates(self):
        self.send_get_allowed_templates()
        return self.recv_get_allowed_templates()

    def send_get_allowed_templates(self):
        self._oprot.writeMessageBegin(
            "get_allowed_templates", TMessageType.CALL, self._seqid
        )
        args = get_allowed_templates_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_allowed_templates(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_allowed_templates_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "get_allowed_templates failed: unknown result",
        )

    def get_templates_by_template(self, template_name):
        """
        Parameters:
         - template_name

        """
        self.send_get_templates_by_template(template_name)
        return self.recv_get_templates_by_template()

    def send_get_templates_by_template(self, template_name):
        self._oprot.writeMessageBegin(
            "get_templates_by_template", TMessageType.CALL, self._seqid
        )
        args = get_templates_by_template_args()
        args.template_name = template_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_templates_by_template(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_templates_by_template_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "get_templates_by_template failed: unknown result",
        )

    def check_template(self, template_name, template_version):
        """
        Parameters:
         - template_name
         - template_version

        """
        self.send_check_template(template_name, template_version)
        return self.recv_check_template()

    def send_check_template(self, template_name, template_version):
        self._oprot.writeMessageBegin("check_template", TMessageType.CALL, self._seqid)
        args = check_template_args()
        args.template_name = template_name
        args.template_version = template_version
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_check_template(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = check_template_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "check_template failed: unknown result",
        )

    def add_udp_security_group(self, server_id):
        """
        Adds a security group to a server

        Parameters:
         - server_id: OpenStack id of the server

        """
        self.send_add_udp_security_group(server_id)
        return self.recv_add_udp_security_group()

    def send_add_udp_security_group(self, server_id):
        self._oprot.writeMessageBegin(
            "add_udp_security_group", TMessageType.CALL, self._seqid
        )
        args = add_udp_security_group_args()
        args.server_id = server_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_udp_security_group(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_udp_security_group_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.r is not None:
            raise result.r
        if result.s is not None:
            raise result.s
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "add_udp_security_group failed: unknown result",
        )

    def get_servers(self):
        """
        Get all servers.
        Returns: List of server instances.

        """
        self.send_get_servers()
        return self.recv_get_servers()

    def send_get_servers(self):
        self._oprot.writeMessageBegin("get_servers", TMessageType.CALL, self._seqid)
        args = get_servers_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_servers(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_servers_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "get_servers failed: unknown result"
        )

    def get_servers_by_ids(self, server_ids):
        """
        * Get list of servers by ids
           *

        Parameters:
         - server_ids

        """
        self.send_get_servers_by_ids(server_ids)
        return self.recv_get_servers_by_ids()

    def send_get_servers_by_ids(self, server_ids):
        self._oprot.writeMessageBegin(
            "get_servers_by_ids", TMessageType.CALL, self._seqid
        )
        args = get_servers_by_ids_args()
        args.server_ids = server_ids
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_servers_by_ids(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_servers_by_ids_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "get_servers_by_ids failed: unknown result",
        )

    def get_servers_by_bibigrid_id(self, bibigrid_id):
        """
        * Get servers by bibigrid cluster id.
           *

        Parameters:
         - bibigrid_id

        """
        self.send_get_servers_by_bibigrid_id(bibigrid_id)
        return self.recv_get_servers_by_bibigrid_id()

    def send_get_servers_by_bibigrid_id(self, bibigrid_id):
        self._oprot.writeMessageBegin(
            "get_servers_by_bibigrid_id", TMessageType.CALL, self._seqid
        )
        args = get_servers_by_bibigrid_id_args()
        args.bibigrid_id = bibigrid_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_servers_by_bibigrid_id(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_servers_by_bibigrid_id_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "get_servers_by_bibigrid_id failed: unknown result",
        )

    def get_cluster_info(self, cluster_id):
        """
        Parameters:
         - cluster_id

        """
        self.send_get_cluster_info(cluster_id)
        return self.recv_get_cluster_info()

    def send_get_cluster_info(self, cluster_id):
        self._oprot.writeMessageBegin(
            "get_cluster_info", TMessageType.CALL, self._seqid
        )
        args = get_cluster_info_args()
        args.cluster_id = cluster_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_cluster_info(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_cluster_info_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "get_cluster_info failed: unknown result",
        )

    def get_server(self, openstack_id):
        """
        Get a Server.
        Returns: A server instance.

        Parameters:
         - openstack_id: Id of the server.

        """
        self.send_get_server(openstack_id)
        return self.recv_get_server()

    def send_get_server(self, openstack_id):
        self._oprot.writeMessageBegin("get_server", TMessageType.CALL, self._seqid)
        args = get_server_args()
        args.openstack_id = openstack_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_server(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_server_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "get_server failed: unknown result"
        )

    def stop_server(self, openstack_id):
        """
        Stop a Server.
        Returns: True if stopped, False if not.

        Parameters:
         - openstack_id: Id of the server.

        """
        self.send_stop_server(openstack_id)
        return self.recv_stop_server()

    def send_stop_server(self, openstack_id):
        self._oprot.writeMessageBegin("stop_server", TMessageType.CALL, self._seqid)
        args = stop_server_args()
        args.openstack_id = openstack_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_stop_server(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = stop_server_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "stop_server failed: unknown result"
        )

    def create_snapshot(self, openstack_id, name, elixir_id, base_tags, description):
        """
        Create Snapshot.
        Returns: Id of new Snapshot


        Parameters:
         - openstack_id: Id of the server
         - name: Name of new Snapshot
         - elixir_id: Elixir-Id of the user who requested creation of Snapshot
         - base_tags: Tags with which the servers image is also tagged ( for connection information at the webapp)
         - description: Description of the new snapshot

        """
        self.send_create_snapshot(openstack_id, name, elixir_id, base_tags, description)
        return self.recv_create_snapshot()

    def send_create_snapshot(
        self, openstack_id, name, elixir_id, base_tags, description
    ):
        self._oprot.writeMessageBegin("create_snapshot", TMessageType.CALL, self._seqid)
        args = create_snapshot_args()
        args.openstack_id = openstack_id
        args.name = name
        args.elixir_id = elixir_id
        args.base_tags = base_tags
        args.description = description
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_snapshot(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_snapshot_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "create_snapshot failed: unknown result",
        )

    def get_limits(self):
        """
        Get Limits of OpenStack Projekt from client.
        Returns: {'maxTotalVolumes': maxTotalVolumes, 'maxTotalVolumeGigabytes': maxTotalVolumeGigabytes,
                  'maxTotalInstances': maxTotalInstances, 'totalRamUsed': totalRamUsed,
                 'totalInstancesUsed': totalInstancesUsed}

        """
        self.send_get_limits()
        return self.recv_get_limits()

    def send_get_limits(self):
        self._oprot.writeMessageBegin("get_limits", TMessageType.CALL, self._seqid)
        args = get_limits_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_limits(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_limits_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "get_limits failed: unknown result"
        )

    def start_cluster(self, public_key, master_instance, worker_instance, user):
        """
        Parameters:
         - public_key
         - master_instance
         - worker_instance
         - user

        """
        self.send_start_cluster(public_key, master_instance, worker_instance, user)
        return self.recv_start_cluster()

    def send_start_cluster(self, public_key, master_instance, worker_instance, user):
        self._oprot.writeMessageBegin("start_cluster", TMessageType.CALL, self._seqid)
        args = start_cluster_args()
        args.public_key = public_key
        args.master_instance = master_instance
        args.worker_instance = worker_instance
        args.user = user
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_start_cluster(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = start_cluster_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "start_cluster failed: unknown result"
        )

    def terminate_cluster(self, cluster_id):
        """
        Parameters:
         - cluster_id

        """
        self.send_terminate_cluster(cluster_id)
        return self.recv_terminate_cluster()

    def send_terminate_cluster(self, cluster_id):
        self._oprot.writeMessageBegin(
            "terminate_cluster", TMessageType.CALL, self._seqid
        )
        args = terminate_cluster_args()
        args.cluster_id = cluster_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_terminate_cluster(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = terminate_cluster_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "terminate_cluster failed: unknown result",
        )

    def delete_image(self, image_id):
        """
        Delete Image.
        Return: True if deleted, False if not

        Parameters:
         - image_id: Id of image

        """
        self.send_delete_image(image_id)
        return self.recv_delete_image()

    def send_delete_image(self, image_id):
        self._oprot.writeMessageBegin("delete_image", TMessageType.CALL, self._seqid)
        args = delete_image_args()
        args.image_id = image_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_delete_image(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = delete_image_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "delete_image failed: unknown result"
        )

    def delete_volume_attachment(self, volume_id, server_id):
        """
        Delete volume attachment
        Return: True if deleted, False if not

        Parameters:
         - volume_id: Id of the attached volume
         - server_id: Id of the server where the volume is attached

        """
        self.send_delete_volume_attachment(volume_id, server_id)
        return self.recv_delete_volume_attachment()

    def send_delete_volume_attachment(self, volume_id, server_id):
        self._oprot.writeMessageBegin(
            "delete_volume_attachment", TMessageType.CALL, self._seqid
        )
        args = delete_volume_attachment_args()
        args.volume_id = volume_id
        args.server_id = server_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_delete_volume_attachment(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = delete_volume_attachment_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "delete_volume_attachment failed: unknown result",
        )

    def delete_volume(self, volume_id):
        """
        Delete volume.
        Returns:  True if deleted, False if not

        Parameters:
         - volume_id

        """
        self.send_delete_volume(volume_id)
        return self.recv_delete_volume()

    def send_delete_volume(self, volume_id):
        self._oprot.writeMessageBegin("delete_volume", TMessageType.CALL, self._seqid)
        args = delete_volume_args()
        args.volume_id = volume_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_delete_volume(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = delete_volume_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "delete_volume failed: unknown result"
        )

    def attach_volume_to_server(self, openstack_id, volume_id):
        """
        Attach volume to server.
        Returns:  True if attached, False if not

        Parameters:
         - openstack_id: Id of server
         - volume_id: Id of volume

        """
        self.send_attach_volume_to_server(openstack_id, volume_id)
        return self.recv_attach_volume_to_server()

    def send_attach_volume_to_server(self, openstack_id, volume_id):
        self._oprot.writeMessageBegin(
            "attach_volume_to_server", TMessageType.CALL, self._seqid
        )
        args = attach_volume_to_server_args()
        args.openstack_id = openstack_id
        args.volume_id = volume_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_attach_volume_to_server(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = attach_volume_to_server_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "attach_volume_to_server failed: unknown result",
        )

    def check_server_status(self, openstack_id, diskspace, volume_id):
        """
        Check status of server.
        Returns: server instance

        Parameters:
         - openstack_id: Id of the server
         - diskspace: diskspace of server(volume will be attached if server is active and diskpace >0)
         - volume_id: Id of the volume

        """
        self.send_check_server_status(openstack_id, diskspace, volume_id)
        return self.recv_check_server_status()

    def send_check_server_status(self, openstack_id, diskspace, volume_id):
        self._oprot.writeMessageBegin(
            "check_server_status", TMessageType.CALL, self._seqid
        )
        args = check_server_status_args()
        args.openstack_id = openstack_id
        args.diskspace = diskspace
        args.volume_id = volume_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_check_server_status(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = check_server_status_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        if result.r is not None:
            raise result.r
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "check_server_status failed: unknown result",
        )

    def setUserPassword(self, user, password):
        """
        Set Password of a User
        Returns: the new password

        Parameters:
         - user: Elixir-Id of the user which wants to set a password
         - password: New password

        """
        self.send_setUserPassword(user, password)
        return self.recv_setUserPassword()

    def send_setUserPassword(self, user, password):
        self._oprot.writeMessageBegin("setUserPassword", TMessageType.CALL, self._seqid)
        args = setUserPassword_args()
        args.user = user
        args.password = password
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_setUserPassword(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = setUserPassword_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "setUserPassword failed: unknown result",
        )

    def resume_server(self, openstack_id):
        """
        Resume Server.
        Returns: True if resumed False if not

        Parameters:
         - openstack_id: Id of the server

        """
        self.send_resume_server(openstack_id)
        return self.recv_resume_server()

    def send_resume_server(self, openstack_id):
        self._oprot.writeMessageBegin("resume_server", TMessageType.CALL, self._seqid)
        args = resume_server_args()
        args.openstack_id = openstack_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_resume_server(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = resume_server_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "resume_server failed: unknown result"
        )

    def create_volume(self, volume_name, diskspace, metadata):
        """
        Create volume.
        Returns: Id of new volume

        Parameters:
         - volume_name: Name of volume
         - diskspace: Diskspace in GB for new volume
         - metadata: Metadata for the new volume

        """
        self.send_create_volume(volume_name, diskspace, metadata)
        return self.recv_create_volume()

    def send_create_volume(self, volume_name, diskspace, metadata):
        self._oprot.writeMessageBegin("create_volume", TMessageType.CALL, self._seqid)
        args = create_volume_args()
        args.volume_name = volume_name
        args.diskspace = diskspace
        args.metadata = metadata
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_volume(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_volume_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.r is not None:
            raise result.r
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "create_volume failed: unknown result"
        )

    def reboot_server(self, server_id, reboot_type):
        """
        Reboot server.
        Returns: True if rebooted False if not

        Parameters:
         - server_id: Id of the server
         - reboot_type: HARD or SOFT

        """
        self.send_reboot_server(server_id, reboot_type)
        return self.recv_reboot_server()

    def send_reboot_server(self, server_id, reboot_type):
        self._oprot.writeMessageBegin("reboot_server", TMessageType.CALL, self._seqid)
        args = reboot_server_args()
        args.server_id = server_id
        args.reboot_type = reboot_type
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_reboot_server(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = reboot_server_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "reboot_server failed: unknown result"
        )


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["check_Version"] = Processor.process_check_Version
        self._processMap["get_client_version"] = Processor.process_get_client_version
        self._processMap["get_gateway_ip"] = Processor.process_get_gateway_ip
        self._processMap[
            "get_calculation_formulars"
        ] = Processor.process_get_calculation_formulars
        self._processMap["import_keypair"] = Processor.process_import_keypair
        self._processMap["get_vm_ports"] = Processor.process_get_vm_ports
        self._processMap["get_Flavors"] = Processor.process_get_Flavors
        self._processMap["get_Images"] = Processor.process_get_Images
        self._processMap["get_Image_with_Tag"] = Processor.process_get_Image_with_Tag
        self._processMap[
            "get_Images_by_filter"
        ] = Processor.process_get_Images_by_filter
        self._processMap["get_volume"] = Processor.process_get_volume
        self._processMap["get_volumes_by_ids"] = Processor.process_get_volumes_by_ids
        self._processMap["delete_server"] = Processor.process_delete_server
        self._processMap[
            "add_metadata_to_server"
        ] = Processor.process_add_metadata_to_server
        self._processMap[
            "delete_metadata_from_server"
        ] = Processor.process_delete_metadata_from_server
        self._processMap[
            "add_floating_ip_to_server"
        ] = Processor.process_add_floating_ip_to_server
        self._processMap["create_connection"] = Processor.process_create_connection
        self._processMap["start_server"] = Processor.process_start_server
        self._processMap[
            "start_server_with_custom_key"
        ] = Processor.process_start_server_with_custom_key
        self._processMap["exist_server"] = Processor.process_exist_server
        self._processMap[
            "create_and_deploy_playbook"
        ] = Processor.process_create_and_deploy_playbook
        self._processMap["get_playbook_logs"] = Processor.process_get_playbook_logs
        self._processMap["has_forc"] = Processor.process_has_forc
        self._processMap["get_forc_url"] = Processor.process_get_forc_url
        self._processMap["create_backend"] = Processor.process_create_backend
        self._processMap["get_backends"] = Processor.process_get_backends
        self._processMap[
            "get_backends_by_owner"
        ] = Processor.process_get_backends_by_owner
        self._processMap[
            "get_backends_by_template"
        ] = Processor.process_get_backends_by_template
        self._processMap["get_backend_by_id"] = Processor.process_get_backend_by_id
        self._processMap["delete_backend"] = Processor.process_delete_backend
        self._processMap["get_templates"] = Processor.process_get_templates
        self._processMap[
            "get_allowed_templates"
        ] = Processor.process_get_allowed_templates
        self._processMap[
            "get_templates_by_template"
        ] = Processor.process_get_templates_by_template
        self._processMap["check_template"] = Processor.process_check_template
        self._processMap[
            "add_udp_security_group"
        ] = Processor.process_add_udp_security_group
        self._processMap["get_servers"] = Processor.process_get_servers
        self._processMap["get_servers_by_ids"] = Processor.process_get_servers_by_ids
        self._processMap[
            "get_servers_by_bibigrid_id"
        ] = Processor.process_get_servers_by_bibigrid_id
        self._processMap["get_cluster_info"] = Processor.process_get_cluster_info
        self._processMap["get_server"] = Processor.process_get_server
        self._processMap["stop_server"] = Processor.process_stop_server
        self._processMap["create_snapshot"] = Processor.process_create_snapshot
        self._processMap["get_limits"] = Processor.process_get_limits
        self._processMap["start_cluster"] = Processor.process_start_cluster
        self._processMap["terminate_cluster"] = Processor.process_terminate_cluster
        self._processMap["delete_image"] = Processor.process_delete_image
        self._processMap[
            "delete_volume_attachment"
        ] = Processor.process_delete_volume_attachment
        self._processMap["delete_volume"] = Processor.process_delete_volume
        self._processMap[
            "attach_volume_to_server"
        ] = Processor.process_attach_volume_to_server
        self._processMap["check_server_status"] = Processor.process_check_server_status
        self._processMap["setUserPassword"] = Processor.process_setUserPassword
        self._processMap["resume_server"] = Processor.process_resume_server
        self._processMap["create_volume"] = Processor.process_create_volume
        self._processMap["reboot_server"] = Processor.process_reboot_server

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(
                TApplicationException.UNKNOWN_METHOD, "Unknown function %s" % (name)
            )
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_check_Version(self, seqid, iprot, oprot):
        args = check_Version_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = check_Version_result()
        try:
            result.success = self._handler.check_Version(args.version)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("check_Version", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_client_version(self, seqid, iprot, oprot):
        args = get_client_version_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_client_version_result()
        try:
            result.success = self._handler.get_client_version()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("get_client_version", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_gateway_ip(self, seqid, iprot, oprot):
        args = get_gateway_ip_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_gateway_ip_result()
        try:
            result.success = self._handler.get_gateway_ip()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("get_gateway_ip", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_calculation_formulars(self, seqid, iprot, oprot):
        args = get_calculation_formulars_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_calculation_formulars_result()
        try:
            result.success = self._handler.get_calculation_formulars()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("get_calculation_formulars", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_import_keypair(self, seqid, iprot, oprot):
        args = import_keypair_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = import_keypair_result()
        try:
            result.success = self._handler.import_keypair(args.keyname, args.public_key)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("import_keypair", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_vm_ports(self, seqid, iprot, oprot):
        args = get_vm_ports_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_vm_ports_result()
        try:
            result.success = self._handler.get_vm_ports(args.openstack_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("get_vm_ports", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_Flavors(self, seqid, iprot, oprot):
        args = get_Flavors_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_Flavors_result()
        try:
            result.success = self._handler.get_Flavors()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("get_Flavors", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_Images(self, seqid, iprot, oprot):
        args = get_Images_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_Images_result()
        try:
            result.success = self._handler.get_Images()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("get_Images", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_Image_with_Tag(self, seqid, iprot, oprot):
        args = get_Image_with_Tag_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_Image_with_Tag_result()
        try:
            result.success = self._handler.get_Image_with_Tag(args.openstack_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("get_Image_with_Tag", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_Images_by_filter(self, seqid, iprot, oprot):
        args = get_Images_by_filter_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_Images_by_filter_result()
        try:
            result.success = self._handler.get_Images_by_filter(args.filter_json)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("get_Images_by_filter", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_volume(self, seqid, iprot, oprot):
        args = get_volume_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_volume_result()
        try:
            result.success = self._handler.get_volume(args.volume_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("get_volume", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_volumes_by_ids(self, seqid, iprot, oprot):
        args = get_volumes_by_ids_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_volumes_by_ids_result()
        try:
            result.success = self._handler.get_volumes_by_ids(args.volume_ids)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("get_volumes_by_ids", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_delete_server(self, seqid, iprot, oprot):
        args = delete_server_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = delete_server_result()
        try:
            result.success = self._handler.delete_server(args.openstack_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except serverNotFoundException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("delete_server", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_metadata_to_server(self, seqid, iprot, oprot):
        args = add_metadata_to_server_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_metadata_to_server_result()
        try:
            result.success = self._handler.add_metadata_to_server(
                args.servername, args.metadata
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except serverNotFoundException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("add_metadata_to_server", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_delete_metadata_from_server(self, seqid, iprot, oprot):
        args = delete_metadata_from_server_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = delete_metadata_from_server_result()
        try:
            result.success = self._handler.delete_metadata_from_server(
                args.servername, args.keys
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except serverNotFoundException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("delete_metadata_from_server", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_floating_ip_to_server(self, seqid, iprot, oprot):
        args = add_floating_ip_to_server_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_floating_ip_to_server_result()
        try:
            result.success = self._handler.add_floating_ip_to_server(
                args.openstack_id, args.network
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except serverNotFoundException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except networkNotFoundException as f:
            msg_type = TMessageType.REPLY
            result.f = f
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("add_floating_ip_to_server", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_connection(self, seqid, iprot, oprot):
        args = create_connection_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_connection_result()
        try:
            result.success = self._handler.create_connection(
                args.username,
                args.password,
                args.auth_url,
                args.user_domain_name,
                args.project_domain_name,
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except authenticationException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("create_connection", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_start_server(self, seqid, iprot, oprot):
        args = start_server_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = start_server_result()
        try:
            result.success = self._handler.start_server(
                args.flavor,
                args.image,
                args.public_key,
                args.servername,
                args.metadata,
                args.diskspace,
                args.volumename,
                args.https,
                args.http,
                args.resenv,
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except nameException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except ressourceException as r:
            msg_type = TMessageType.REPLY
            result.r = r
        except serverNotFoundException as s:
            msg_type = TMessageType.REPLY
            result.s = s
        except networkNotFoundException as n:
            msg_type = TMessageType.REPLY
            result.n = n
        except imageNotFoundException as i:
            msg_type = TMessageType.REPLY
            result.i = i
        except flavorNotFoundException as f:
            msg_type = TMessageType.REPLY
            result.f = f
        except otherException as o:
            msg_type = TMessageType.REPLY
            result.o = o
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("start_server", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_start_server_with_custom_key(self, seqid, iprot, oprot):
        args = start_server_with_custom_key_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = start_server_with_custom_key_result()
        try:
            result.success = self._handler.start_server_with_custom_key(
                args.flavor,
                args.image,
                args.servername,
                args.metadata,
                args.diskspace,
                args.volumename,
                args.http,
                args.https,
                args.resenv,
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except nameException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except ressourceException as r:
            msg_type = TMessageType.REPLY
            result.r = r
        except serverNotFoundException as s:
            msg_type = TMessageType.REPLY
            result.s = s
        except networkNotFoundException as n:
            msg_type = TMessageType.REPLY
            result.n = n
        except imageNotFoundException as i:
            msg_type = TMessageType.REPLY
            result.i = i
        except flavorNotFoundException as f:
            msg_type = TMessageType.REPLY
            result.f = f
        except otherException as o:
            msg_type = TMessageType.REPLY
            result.o = o
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("start_server_with_custom_key", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_exist_server(self, seqid, iprot, oprot):
        args = exist_server_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = exist_server_result()
        try:
            result.success = self._handler.exist_server(args.name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("exist_server", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_and_deploy_playbook(self, seqid, iprot, oprot):
        args = create_and_deploy_playbook_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_and_deploy_playbook_result()
        try:
            result.success = self._handler.create_and_deploy_playbook(
                args.public_key, args.playbooks_information, args.openstack_id
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("create_and_deploy_playbook", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_playbook_logs(self, seqid, iprot, oprot):
        args = get_playbook_logs_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_playbook_logs_result()
        try:
            result.success = self._handler.get_playbook_logs(args.openstack_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("get_playbook_logs", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_has_forc(self, seqid, iprot, oprot):
        args = has_forc_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = has_forc_result()
        try:
            result.success = self._handler.has_forc()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("has_forc", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_forc_url(self, seqid, iprot, oprot):
        args = get_forc_url_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_forc_url_result()
        try:
            result.success = self._handler.get_forc_url()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("get_forc_url", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_backend(self, seqid, iprot, oprot):
        args = create_backend_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_backend_result()
        try:
            result.success = self._handler.create_backend(
                args.elixir_id, args.user_key_url, args.template, args.upstream_url
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("create_backend", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_backends(self, seqid, iprot, oprot):
        args = get_backends_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_backends_result()
        try:
            result.success = self._handler.get_backends()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("get_backends", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_backends_by_owner(self, seqid, iprot, oprot):
        args = get_backends_by_owner_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_backends_by_owner_result()
        try:
            result.success = self._handler.get_backends_by_owner(args.elixir_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("get_backends_by_owner", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_backends_by_template(self, seqid, iprot, oprot):
        args = get_backends_by_template_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_backends_by_template_result()
        try:
            result.success = self._handler.get_backends_by_template(args.template)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("get_backends_by_template", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_backend_by_id(self, seqid, iprot, oprot):
        args = get_backend_by_id_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_backend_by_id_result()
        try:
            result.success = self._handler.get_backend_by_id(args.id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("get_backend_by_id", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_delete_backend(self, seqid, iprot, oprot):
        args = delete_backend_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = delete_backend_result()
        try:
            result.success = self._handler.delete_backend(args.id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("delete_backend", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_templates(self, seqid, iprot, oprot):
        args = get_templates_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_templates_result()
        try:
            result.success = self._handler.get_templates()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("get_templates", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_allowed_templates(self, seqid, iprot, oprot):
        args = get_allowed_templates_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_allowed_templates_result()
        try:
            result.success = self._handler.get_allowed_templates()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("get_allowed_templates", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_templates_by_template(self, seqid, iprot, oprot):
        args = get_templates_by_template_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_templates_by_template_result()
        try:
            result.success = self._handler.get_templates_by_template(args.template_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("get_templates_by_template", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_check_template(self, seqid, iprot, oprot):
        args = check_template_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = check_template_result()
        try:
            result.success = self._handler.check_template(
                args.template_name, args.template_version
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("check_template", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_udp_security_group(self, seqid, iprot, oprot):
        args = add_udp_security_group_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_udp_security_group_result()
        try:
            result.success = self._handler.add_udp_security_group(args.server_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ressourceException as r:
            msg_type = TMessageType.REPLY
            result.r = r
        except serverNotFoundException as s:
            msg_type = TMessageType.REPLY
            result.s = s
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("add_udp_security_group", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_servers(self, seqid, iprot, oprot):
        args = get_servers_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_servers_result()
        try:
            result.success = self._handler.get_servers()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("get_servers", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_servers_by_ids(self, seqid, iprot, oprot):
        args = get_servers_by_ids_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_servers_by_ids_result()
        try:
            result.success = self._handler.get_servers_by_ids(args.server_ids)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("get_servers_by_ids", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_servers_by_bibigrid_id(self, seqid, iprot, oprot):
        args = get_servers_by_bibigrid_id_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_servers_by_bibigrid_id_result()
        try:
            result.success = self._handler.get_servers_by_bibigrid_id(args.bibigrid_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("get_servers_by_bibigrid_id", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_cluster_info(self, seqid, iprot, oprot):
        args = get_cluster_info_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_cluster_info_result()
        try:
            result.success = self._handler.get_cluster_info(args.cluster_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("get_cluster_info", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_server(self, seqid, iprot, oprot):
        args = get_server_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_server_result()
        try:
            result.success = self._handler.get_server(args.openstack_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except serverNotFoundException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("get_server", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_stop_server(self, seqid, iprot, oprot):
        args = stop_server_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = stop_server_result()
        try:
            result.success = self._handler.stop_server(args.openstack_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except serverNotFoundException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("stop_server", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_snapshot(self, seqid, iprot, oprot):
        args = create_snapshot_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_snapshot_result()
        try:
            result.success = self._handler.create_snapshot(
                args.openstack_id,
                args.name,
                args.elixir_id,
                args.base_tags,
                args.description,
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except serverNotFoundException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("create_snapshot", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_limits(self, seqid, iprot, oprot):
        args = get_limits_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_limits_result()
        try:
            result.success = self._handler.get_limits()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("get_limits", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_start_cluster(self, seqid, iprot, oprot):
        args = start_cluster_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = start_cluster_result()
        try:
            result.success = self._handler.start_cluster(
                args.public_key, args.master_instance, args.worker_instance, args.user
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("start_cluster", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_terminate_cluster(self, seqid, iprot, oprot):
        args = terminate_cluster_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = terminate_cluster_result()
        try:
            result.success = self._handler.terminate_cluster(args.cluster_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("terminate_cluster", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_delete_image(self, seqid, iprot, oprot):
        args = delete_image_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = delete_image_result()
        try:
            result.success = self._handler.delete_image(args.image_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except imageNotFoundException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("delete_image", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_delete_volume_attachment(self, seqid, iprot, oprot):
        args = delete_volume_attachment_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = delete_volume_attachment_result()
        try:
            result.success = self._handler.delete_volume_attachment(
                args.volume_id, args.server_id
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except serverNotFoundException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("delete_volume_attachment", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_delete_volume(self, seqid, iprot, oprot):
        args = delete_volume_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = delete_volume_result()
        try:
            result.success = self._handler.delete_volume(args.volume_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("delete_volume", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_attach_volume_to_server(self, seqid, iprot, oprot):
        args = attach_volume_to_server_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = attach_volume_to_server_result()
        try:
            result.success = self._handler.attach_volume_to_server(
                args.openstack_id, args.volume_id
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except serverNotFoundException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("attach_volume_to_server", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_check_server_status(self, seqid, iprot, oprot):
        args = check_server_status_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = check_server_status_result()
        try:
            result.success = self._handler.check_server_status(
                args.openstack_id, args.diskspace, args.volume_id
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except serverNotFoundException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except ressourceException as r:
            msg_type = TMessageType.REPLY
            result.r = r
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("check_server_status", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_setUserPassword(self, seqid, iprot, oprot):
        args = setUserPassword_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = setUserPassword_result()
        try:
            result.success = self._handler.setUserPassword(args.user, args.password)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except otherException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("setUserPassword", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_resume_server(self, seqid, iprot, oprot):
        args = resume_server_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = resume_server_result()
        try:
            result.success = self._handler.resume_server(args.openstack_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except serverNotFoundException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("resume_server", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_volume(self, seqid, iprot, oprot):
        args = create_volume_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_volume_result()
        try:
            result.success = self._handler.create_volume(
                args.volume_name, args.diskspace, args.metadata
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ressourceException as r:
            msg_type = TMessageType.REPLY
            result.r = r
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("create_volume", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_reboot_server(self, seqid, iprot, oprot):
        args = reboot_server_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = reboot_server_result()
        try:
            result.success = self._handler.reboot_server(
                args.server_id, args.reboot_type
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except serverNotFoundException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("reboot_server", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES


class check_Version_args(object):
    """
    Attributes:
     - version

    """

    def __init__(
        self, version=None,
    ):
        self.version = version

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.version = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("check_Version_args")
        if self.version is not None:
            oprot.writeFieldBegin("version", TType.DOUBLE, 1)
            oprot.writeDouble(self.version)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(check_Version_args)
check_Version_args.thrift_spec = (
    None,  # 0
    (1, TType.DOUBLE, "version", None, None,),  # 1
)


class check_Version_result(object):
    """
    Attributes:
     - success

    """

    def __init__(
        self, success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("check_Version_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(check_Version_result)
check_Version_result.thrift_spec = ((0, TType.BOOL, "success", None, None,),)  # 0


class get_client_version_args(object):
    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_client_version_args")
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_client_version_args)
get_client_version_args.thrift_spec = ()


class get_client_version_result(object):
    """
    Attributes:
     - success

    """

    def __init__(
        self, success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_client_version_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRING, 0)
            oprot.writeString(
                self.success.encode("utf-8")
                if sys.version_info[0] == 2
                else self.success
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_client_version_result)
get_client_version_result.thrift_spec = (
    (0, TType.STRING, "success", "UTF8", None,),  # 0
)


class get_gateway_ip_args(object):
    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_gateway_ip_args")
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_gateway_ip_args)
get_gateway_ip_args.thrift_spec = ()


class get_gateway_ip_result(object):
    """
    Attributes:
     - success

    """

    def __init__(
        self, success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype24, _vtype25, _size23) = iprot.readMapBegin()
                    for _i27 in range(_size23):
                        _key28 = (
                            iprot.readString().decode("utf-8")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        _val29 = (
                            iprot.readString().decode("utf-8")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.success[_key28] = _val29
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_gateway_ip_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for kiter30, viter31 in self.success.items():
                oprot.writeString(
                    kiter30.encode("utf-8") if sys.version_info[0] == 2 else kiter30
                )
                oprot.writeString(
                    viter31.encode("utf-8") if sys.version_info[0] == 2 else viter31
                )
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_gateway_ip_result)
get_gateway_ip_result.thrift_spec = (
    (
        0,
        TType.MAP,
        "success",
        (TType.STRING, "UTF8", TType.STRING, "UTF8", False),
        None,
    ),  # 0
)


class get_calculation_formulars_args(object):
    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_calculation_formulars_args")
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_calculation_formulars_args)
get_calculation_formulars_args.thrift_spec = ()


class get_calculation_formulars_result(object):
    """
    Attributes:
     - success

    """

    def __init__(
        self, success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype33, _vtype34, _size32) = iprot.readMapBegin()
                    for _i36 in range(_size32):
                        _key37 = (
                            iprot.readString().decode("utf-8")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        _val38 = (
                            iprot.readString().decode("utf-8")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.success[_key37] = _val38
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_calculation_formulars_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for kiter39, viter40 in self.success.items():
                oprot.writeString(
                    kiter39.encode("utf-8") if sys.version_info[0] == 2 else kiter39
                )
                oprot.writeString(
                    viter40.encode("utf-8") if sys.version_info[0] == 2 else viter40
                )
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_calculation_formulars_result)
get_calculation_formulars_result.thrift_spec = (
    (
        0,
        TType.MAP,
        "success",
        (TType.STRING, "UTF8", TType.STRING, "UTF8", False),
        None,
    ),  # 0
)


class import_keypair_args(object):
    """
    Attributes:
     - keyname: Name for the keypair
     - public_key: The public key

    """

    def __init__(
        self, keyname=None, public_key=None,
    ):
        self.keyname = keyname
        self.public_key = public_key

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.keyname = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.public_key = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("import_keypair_args")
        if self.keyname is not None:
            oprot.writeFieldBegin("keyname", TType.STRING, 1)
            oprot.writeString(
                self.keyname.encode("utf-8")
                if sys.version_info[0] == 2
                else self.keyname
            )
            oprot.writeFieldEnd()
        if self.public_key is not None:
            oprot.writeFieldBegin("public_key", TType.STRING, 2)
            oprot.writeString(
                self.public_key.encode("utf-8")
                if sys.version_info[0] == 2
                else self.public_key
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(import_keypair_args)
import_keypair_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, "keyname", "UTF8", None,),  # 1
    (2, TType.STRING, "public_key", "UTF8", None,),  # 2
)


class import_keypair_result(object):
    """
    Attributes:
     - success

    """

    def __init__(
        self, success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("import_keypair_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRING, 0)
            oprot.writeString(
                self.success.encode("utf-8")
                if sys.version_info[0] == 2
                else self.success
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(import_keypair_result)
import_keypair_result.thrift_spec = ((0, TType.STRING, "success", "UTF8", None,),)  # 0


class get_vm_ports_args(object):
    """
    Attributes:
     - openstack_id: Id of server

    """

    def __init__(
        self, openstack_id=None,
    ):
        self.openstack_id = openstack_id

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.openstack_id = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_vm_ports_args")
        if self.openstack_id is not None:
            oprot.writeFieldBegin("openstack_id", TType.STRING, 1)
            oprot.writeString(
                self.openstack_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.openstack_id
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_vm_ports_args)
get_vm_ports_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, "openstack_id", "UTF8", None,),  # 1
)


class get_vm_ports_result(object):
    """
    Attributes:
     - success

    """

    def __init__(
        self, success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype42, _vtype43, _size41) = iprot.readMapBegin()
                    for _i45 in range(_size41):
                        _key46 = (
                            iprot.readString().decode("utf-8")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        _val47 = (
                            iprot.readString().decode("utf-8")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.success[_key46] = _val47
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_vm_ports_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for kiter48, viter49 in self.success.items():
                oprot.writeString(
                    kiter48.encode("utf-8") if sys.version_info[0] == 2 else kiter48
                )
                oprot.writeString(
                    viter49.encode("utf-8") if sys.version_info[0] == 2 else viter49
                )
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_vm_ports_result)
get_vm_ports_result.thrift_spec = (
    (
        0,
        TType.MAP,
        "success",
        (TType.STRING, "UTF8", TType.STRING, "UTF8", False),
        None,
    ),  # 0
)


class get_Flavors_args(object):
    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_Flavors_args")
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_Flavors_args)
get_Flavors_args.thrift_spec = ()


class get_Flavors_result(object):
    """
    Attributes:
     - success

    """

    def __init__(
        self, success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype53, _size50) = iprot.readListBegin()
                    for _i54 in range(_size50):
                        _elem55 = Flavor()
                        _elem55.read(iprot)
                        self.success.append(_elem55)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_Flavors_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter56 in self.success:
                iter56.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_Flavors_result)
get_Flavors_result.thrift_spec = (
    (0, TType.LIST, "success", (TType.STRUCT, [Flavor, None], False), None,),  # 0
)


class get_Images_args(object):
    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_Images_args")
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_Images_args)
get_Images_args.thrift_spec = ()


class get_Images_result(object):
    """
    Attributes:
     - success

    """

    def __init__(
        self, success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype60, _size57) = iprot.readListBegin()
                    for _i61 in range(_size57):
                        _elem62 = Image()
                        _elem62.read(iprot)
                        self.success.append(_elem62)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_Images_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter63 in self.success:
                iter63.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_Images_result)
get_Images_result.thrift_spec = (
    (0, TType.LIST, "success", (TType.STRUCT, [Image, None], False), None,),  # 0
)


class get_Image_with_Tag_args(object):
    """
    Attributes:
     - openstack_id

    """

    def __init__(
        self, openstack_id=None,
    ):
        self.openstack_id = openstack_id

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.openstack_id = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_Image_with_Tag_args")
        if self.openstack_id is not None:
            oprot.writeFieldBegin("openstack_id", TType.STRING, 1)
            oprot.writeString(
                self.openstack_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.openstack_id
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_Image_with_Tag_args)
get_Image_with_Tag_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, "openstack_id", "UTF8", None,),  # 1
)


class get_Image_with_Tag_result(object):
    """
    Attributes:
     - success

    """

    def __init__(
        self, success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Image()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_Image_with_Tag_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_Image_with_Tag_result)
get_Image_with_Tag_result.thrift_spec = (
    (0, TType.STRUCT, "success", [Image, None], None,),  # 0
)


class get_Images_by_filter_args(object):
    """
    Attributes:
     - filter_json

    """

    def __init__(
        self, filter_json=None,
    ):
        self.filter_json = filter_json

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.filter_json = {}
                    (_ktype65, _vtype66, _size64) = iprot.readMapBegin()
                    for _i68 in range(_size64):
                        _key69 = (
                            iprot.readString().decode("utf-8")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        _val70 = (
                            iprot.readString().decode("utf-8")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.filter_json[_key69] = _val70
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_Images_by_filter_args")
        if self.filter_json is not None:
            oprot.writeFieldBegin("filter_json", TType.MAP, 1)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.filter_json))
            for kiter71, viter72 in self.filter_json.items():
                oprot.writeString(
                    kiter71.encode("utf-8") if sys.version_info[0] == 2 else kiter71
                )
                oprot.writeString(
                    viter72.encode("utf-8") if sys.version_info[0] == 2 else viter72
                )
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_Images_by_filter_args)
get_Images_by_filter_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.MAP,
        "filter_json",
        (TType.STRING, "UTF8", TType.STRING, "UTF8", False),
        None,
    ),  # 1
)


class get_Images_by_filter_result(object):
    """
    Attributes:
     - success

    """

    def __init__(
        self, success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype76, _size73) = iprot.readListBegin()
                    for _i77 in range(_size73):
                        _elem78 = Image()
                        _elem78.read(iprot)
                        self.success.append(_elem78)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_Images_by_filter_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter79 in self.success:
                iter79.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_Images_by_filter_result)
get_Images_by_filter_result.thrift_spec = (
    (0, TType.LIST, "success", (TType.STRUCT, [Image, None], False), None,),  # 0
)


class get_volume_args(object):
    """
    Attributes:
     - volume_id

    """

    def __init__(
        self, volume_id=None,
    ):
        self.volume_id = volume_id

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.volume_id = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_volume_args")
        if self.volume_id is not None:
            oprot.writeFieldBegin("volume_id", TType.STRING, 1)
            oprot.writeString(
                self.volume_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.volume_id
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_volume_args)
get_volume_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, "volume_id", "UTF8", None,),  # 1
)


class get_volume_result(object):
    """
    Attributes:
     - success

    """

    def __init__(
        self, success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Volume()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_volume_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_volume_result)
get_volume_result.thrift_spec = (
    (0, TType.STRUCT, "success", [Volume, None], None,),  # 0
)


class get_volumes_by_ids_args(object):
    """
    Attributes:
     - volume_ids

    """

    def __init__(
        self, volume_ids=None,
    ):
        self.volume_ids = volume_ids

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.volume_ids = []
                    (_etype83, _size80) = iprot.readListBegin()
                    for _i84 in range(_size80):
                        _elem85 = (
                            iprot.readString().decode("utf-8")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.volume_ids.append(_elem85)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_volumes_by_ids_args")
        if self.volume_ids is not None:
            oprot.writeFieldBegin("volume_ids", TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.volume_ids))
            for iter86 in self.volume_ids:
                oprot.writeString(
                    iter86.encode("utf-8") if sys.version_info[0] == 2 else iter86
                )
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_volumes_by_ids_args)
get_volumes_by_ids_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, "volume_ids", (TType.STRING, "UTF8", False), None,),  # 1
)


class get_volumes_by_ids_result(object):
    """
    Attributes:
     - success

    """

    def __init__(
        self, success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype90, _size87) = iprot.readListBegin()
                    for _i91 in range(_size87):
                        _elem92 = Volume()
                        _elem92.read(iprot)
                        self.success.append(_elem92)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_volumes_by_ids_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter93 in self.success:
                iter93.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_volumes_by_ids_result)
get_volumes_by_ids_result.thrift_spec = (
    (0, TType.LIST, "success", (TType.STRUCT, [Volume, None], False), None,),  # 0
)


class delete_server_args(object):
    """
    Attributes:
     - openstack_id: Id of the server.

    """

    def __init__(
        self, openstack_id=None,
    ):
        self.openstack_id = openstack_id

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.openstack_id = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("delete_server_args")
        if self.openstack_id is not None:
            oprot.writeFieldBegin("openstack_id", TType.STRING, 1)
            oprot.writeString(
                self.openstack_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.openstack_id
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(delete_server_args)
delete_server_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, "openstack_id", "UTF8", None,),  # 1
)


class delete_server_result(object):
    """
    Attributes:
     - success
     - e

    """

    def __init__(
        self, success=None, e=None,
    ):
        self.success = success
        self.e = e

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = serverNotFoundException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("delete_server_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin("e", TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(delete_server_result)
delete_server_result.thrift_spec = (
    (0, TType.BOOL, "success", None, None,),  # 0
    (1, TType.STRUCT, "e", [serverNotFoundException, None], None,),  # 1
)


class add_metadata_to_server_args(object):
    """
    Attributes:
     - servername
     - metadata

    """

    def __init__(
        self, servername=None, metadata=None,
    ):
        self.servername = servername
        self.metadata = metadata

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.servername = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.metadata = {}
                    (_ktype95, _vtype96, _size94) = iprot.readMapBegin()
                    for _i98 in range(_size94):
                        _key99 = (
                            iprot.readString().decode("utf-8")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        _val100 = (
                            iprot.readString().decode("utf-8")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.metadata[_key99] = _val100
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("add_metadata_to_server_args")
        if self.servername is not None:
            oprot.writeFieldBegin("servername", TType.STRING, 1)
            oprot.writeString(
                self.servername.encode("utf-8")
                if sys.version_info[0] == 2
                else self.servername
            )
            oprot.writeFieldEnd()
        if self.metadata is not None:
            oprot.writeFieldBegin("metadata", TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.metadata))
            for kiter101, viter102 in self.metadata.items():
                oprot.writeString(
                    kiter101.encode("utf-8") if sys.version_info[0] == 2 else kiter101
                )
                oprot.writeString(
                    viter102.encode("utf-8") if sys.version_info[0] == 2 else viter102
                )
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(add_metadata_to_server_args)
add_metadata_to_server_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, "servername", "UTF8", None,),  # 1
    (
        2,
        TType.MAP,
        "metadata",
        (TType.STRING, "UTF8", TType.STRING, "UTF8", False),
        None,
    ),  # 2
)


class add_metadata_to_server_result(object):
    """
    Attributes:
     - success
     - e

    """

    def __init__(
        self, success=None, e=None,
    ):
        self.success = success
        self.e = e

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype104, _vtype105, _size103) = iprot.readMapBegin()
                    for _i107 in range(_size103):
                        _key108 = (
                            iprot.readString().decode("utf-8")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        _val109 = (
                            iprot.readString().decode("utf-8")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.success[_key108] = _val109
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = serverNotFoundException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("add_metadata_to_server_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for kiter110, viter111 in self.success.items():
                oprot.writeString(
                    kiter110.encode("utf-8") if sys.version_info[0] == 2 else kiter110
                )
                oprot.writeString(
                    viter111.encode("utf-8") if sys.version_info[0] == 2 else viter111
                )
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin("e", TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(add_metadata_to_server_result)
add_metadata_to_server_result.thrift_spec = (
    (
        0,
        TType.MAP,
        "success",
        (TType.STRING, "UTF8", TType.STRING, "UTF8", False),
        None,
    ),  # 0
    (1, TType.STRUCT, "e", [serverNotFoundException, None], None,),  # 1
)


class delete_metadata_from_server_args(object):
    """
    Attributes:
     - servername
     - keys

    """

    def __init__(
        self, servername=None, keys=None,
    ):
        self.servername = servername
        self.keys = keys

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.servername = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.SET:
                    self.keys = set()
                    (_etype115, _size112) = iprot.readSetBegin()
                    for _i116 in range(_size112):
                        _elem117 = (
                            iprot.readString().decode("utf-8")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.keys.add(_elem117)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("delete_metadata_from_server_args")
        if self.servername is not None:
            oprot.writeFieldBegin("servername", TType.STRING, 1)
            oprot.writeString(
                self.servername.encode("utf-8")
                if sys.version_info[0] == 2
                else self.servername
            )
            oprot.writeFieldEnd()
        if self.keys is not None:
            oprot.writeFieldBegin("keys", TType.SET, 2)
            oprot.writeSetBegin(TType.STRING, len(self.keys))
            for iter118 in self.keys:
                oprot.writeString(
                    iter118.encode("utf-8") if sys.version_info[0] == 2 else iter118
                )
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(delete_metadata_from_server_args)
delete_metadata_from_server_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, "servername", "UTF8", None,),  # 1
    (2, TType.SET, "keys", (TType.STRING, "UTF8", False), None,),  # 2
)


class delete_metadata_from_server_result(object):
    """
    Attributes:
     - success
     - e

    """

    def __init__(
        self, success=None, e=None,
    ):
        self.success = success
        self.e = e

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.SET:
                    self.success = set()
                    (_etype122, _size119) = iprot.readSetBegin()
                    for _i123 in range(_size119):
                        _elem124 = (
                            iprot.readString().decode("utf-8")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.success.add(_elem124)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = serverNotFoundException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("delete_metadata_from_server_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.SET, 0)
            oprot.writeSetBegin(TType.STRING, len(self.success))
            for iter125 in self.success:
                oprot.writeString(
                    iter125.encode("utf-8") if sys.version_info[0] == 2 else iter125
                )
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin("e", TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(delete_metadata_from_server_result)
delete_metadata_from_server_result.thrift_spec = (
    (0, TType.SET, "success", (TType.STRING, "UTF8", False), None,),  # 0
    (1, TType.STRUCT, "e", [serverNotFoundException, None], None,),  # 1
)


class add_floating_ip_to_server_args(object):
    """
    Attributes:
     - openstack_id: Id of the server
     - network: Network name of the network which provides the floating Ip.

    """

    def __init__(
        self, openstack_id=None, network=None,
    ):
        self.openstack_id = openstack_id
        self.network = network

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.openstack_id = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.network = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("add_floating_ip_to_server_args")
        if self.openstack_id is not None:
            oprot.writeFieldBegin("openstack_id", TType.STRING, 1)
            oprot.writeString(
                self.openstack_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.openstack_id
            )
            oprot.writeFieldEnd()
        if self.network is not None:
            oprot.writeFieldBegin("network", TType.STRING, 2)
            oprot.writeString(
                self.network.encode("utf-8")
                if sys.version_info[0] == 2
                else self.network
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(add_floating_ip_to_server_args)
add_floating_ip_to_server_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, "openstack_id", "UTF8", None,),  # 1
    (2, TType.STRING, "network", "UTF8", None,),  # 2
)


class add_floating_ip_to_server_result(object):
    """
    Attributes:
     - success
     - e
     - f

    """

    def __init__(
        self, success=None, e=None, f=None,
    ):
        self.success = success
        self.e = e
        self.f = f

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = serverNotFoundException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.f = networkNotFoundException()
                    self.f.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("add_floating_ip_to_server_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRING, 0)
            oprot.writeString(
                self.success.encode("utf-8")
                if sys.version_info[0] == 2
                else self.success
            )
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin("e", TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        if self.f is not None:
            oprot.writeFieldBegin("f", TType.STRUCT, 2)
            self.f.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(add_floating_ip_to_server_result)
add_floating_ip_to_server_result.thrift_spec = (
    (0, TType.STRING, "success", "UTF8", None,),  # 0
    (1, TType.STRUCT, "e", [serverNotFoundException, None], None,),  # 1
    (2, TType.STRUCT, "f", [networkNotFoundException, None], None,),  # 2
)


class create_connection_args(object):
    """
    Attributes:
     - username: Name of the OpenStack user.
     - password: Password of the OpenStack user
     - auth_url: Auth Url from OpenStack
     - user_domain_name: Name of the project from the OpenStack user.
    4:string project_name,

    /** Domain name of OpenStack
     - project_domain_name: Project domain name of OpenStack

    """

    def __init__(
        self,
        username=None,
        password=None,
        auth_url=None,
        user_domain_name=None,
        project_domain_name=None,
    ):
        self.username = username
        self.password = password
        self.auth_url = auth_url
        self.user_domain_name = user_domain_name
        self.project_domain_name = project_domain_name

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.username = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.password = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.auth_url = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.user_domain_name = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.project_domain_name = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("create_connection_args")
        if self.username is not None:
            oprot.writeFieldBegin("username", TType.STRING, 1)
            oprot.writeString(
                self.username.encode("utf-8")
                if sys.version_info[0] == 2
                else self.username
            )
            oprot.writeFieldEnd()
        if self.password is not None:
            oprot.writeFieldBegin("password", TType.STRING, 2)
            oprot.writeString(
                self.password.encode("utf-8")
                if sys.version_info[0] == 2
                else self.password
            )
            oprot.writeFieldEnd()
        if self.auth_url is not None:
            oprot.writeFieldBegin("auth_url", TType.STRING, 3)
            oprot.writeString(
                self.auth_url.encode("utf-8")
                if sys.version_info[0] == 2
                else self.auth_url
            )
            oprot.writeFieldEnd()
        if self.user_domain_name is not None:
            oprot.writeFieldBegin("user_domain_name", TType.STRING, 5)
            oprot.writeString(
                self.user_domain_name.encode("utf-8")
                if sys.version_info[0] == 2
                else self.user_domain_name
            )
            oprot.writeFieldEnd()
        if self.project_domain_name is not None:
            oprot.writeFieldBegin("project_domain_name", TType.STRING, 6)
            oprot.writeString(
                self.project_domain_name.encode("utf-8")
                if sys.version_info[0] == 2
                else self.project_domain_name
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(create_connection_args)
create_connection_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, "username", "UTF8", None,),  # 1
    (2, TType.STRING, "password", "UTF8", None,),  # 2
    (3, TType.STRING, "auth_url", "UTF8", None,),  # 3
    None,  # 4
    (5, TType.STRING, "user_domain_name", "UTF8", None,),  # 5
    (6, TType.STRING, "project_domain_name", "UTF8", None,),  # 6
)


class create_connection_result(object):
    """
    Attributes:
     - success
     - e

    """

    def __init__(
        self, success=None, e=None,
    ):
        self.success = success
        self.e = e

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = authenticationException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("create_connection_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin("e", TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(create_connection_result)
create_connection_result.thrift_spec = (
    (0, TType.BOOL, "success", None, None,),  # 0
    (1, TType.STRUCT, "e", [authenticationException, None], None,),  # 1
)


class start_server_args(object):
    """
    Attributes:
     - flavor: Name of the  Flavor to use.
     - image: Name of the image to use.
     - public_key: Public Key to use
     - servername: Name for the new server
     - metadata: Metadata for the new instance
     - diskspace: Diskspace in GB for additional volume.
     - volumename: Name of additional Volume
     - https
     - http
     - resenv

    """

    def __init__(
        self,
        flavor=None,
        image=None,
        public_key=None,
        servername=None,
        metadata=None,
        diskspace=None,
        volumename=None,
        https=None,
        http=None,
        resenv=None,
    ):
        self.flavor = flavor
        self.image = image
        self.public_key = public_key
        self.servername = servername
        self.metadata = metadata
        self.diskspace = diskspace
        self.volumename = volumename
        self.https = https
        self.http = http
        self.resenv = resenv

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.flavor = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.image = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.public_key = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.servername = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.MAP:
                    self.metadata = {}
                    (_ktype127, _vtype128, _size126) = iprot.readMapBegin()
                    for _i130 in range(_size126):
                        _key131 = (
                            iprot.readString().decode("utf-8")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        _val132 = (
                            iprot.readString().decode("utf-8")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.metadata[_key131] = _val132
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.diskspace = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.volumename = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.https = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.BOOL:
                    self.http = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.LIST:
                    self.resenv = []
                    (_etype136, _size133) = iprot.readListBegin()
                    for _i137 in range(_size133):
                        _elem138 = (
                            iprot.readString().decode("utf-8")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.resenv.append(_elem138)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("start_server_args")
        if self.flavor is not None:
            oprot.writeFieldBegin("flavor", TType.STRING, 1)
            oprot.writeString(
                self.flavor.encode("utf-8") if sys.version_info[0] == 2 else self.flavor
            )
            oprot.writeFieldEnd()
        if self.image is not None:
            oprot.writeFieldBegin("image", TType.STRING, 2)
            oprot.writeString(
                self.image.encode("utf-8") if sys.version_info[0] == 2 else self.image
            )
            oprot.writeFieldEnd()
        if self.public_key is not None:
            oprot.writeFieldBegin("public_key", TType.STRING, 3)
            oprot.writeString(
                self.public_key.encode("utf-8")
                if sys.version_info[0] == 2
                else self.public_key
            )
            oprot.writeFieldEnd()
        if self.servername is not None:
            oprot.writeFieldBegin("servername", TType.STRING, 4)
            oprot.writeString(
                self.servername.encode("utf-8")
                if sys.version_info[0] == 2
                else self.servername
            )
            oprot.writeFieldEnd()
        if self.metadata is not None:
            oprot.writeFieldBegin("metadata", TType.MAP, 5)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.metadata))
            for kiter139, viter140 in self.metadata.items():
                oprot.writeString(
                    kiter139.encode("utf-8") if sys.version_info[0] == 2 else kiter139
                )
                oprot.writeString(
                    viter140.encode("utf-8") if sys.version_info[0] == 2 else viter140
                )
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.diskspace is not None:
            oprot.writeFieldBegin("diskspace", TType.STRING, 6)
            oprot.writeString(
                self.diskspace.encode("utf-8")
                if sys.version_info[0] == 2
                else self.diskspace
            )
            oprot.writeFieldEnd()
        if self.volumename is not None:
            oprot.writeFieldBegin("volumename", TType.STRING, 7)
            oprot.writeString(
                self.volumename.encode("utf-8")
                if sys.version_info[0] == 2
                else self.volumename
            )
            oprot.writeFieldEnd()
        if self.https is not None:
            oprot.writeFieldBegin("https", TType.BOOL, 8)
            oprot.writeBool(self.https)
            oprot.writeFieldEnd()
        if self.http is not None:
            oprot.writeFieldBegin("http", TType.BOOL, 9)
            oprot.writeBool(self.http)
            oprot.writeFieldEnd()
        if self.resenv is not None:
            oprot.writeFieldBegin("resenv", TType.LIST, 10)
            oprot.writeListBegin(TType.STRING, len(self.resenv))
            for iter141 in self.resenv:
                oprot.writeString(
                    iter141.encode("utf-8") if sys.version_info[0] == 2 else iter141
                )
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(start_server_args)
start_server_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, "flavor", "UTF8", None,),  # 1
    (2, TType.STRING, "image", "UTF8", None,),  # 2
    (3, TType.STRING, "public_key", "UTF8", None,),  # 3
    (4, TType.STRING, "servername", "UTF8", None,),  # 4
    (
        5,
        TType.MAP,
        "metadata",
        (TType.STRING, "UTF8", TType.STRING, "UTF8", False),
        None,
    ),  # 5
    (6, TType.STRING, "diskspace", "UTF8", None,),  # 6
    (7, TType.STRING, "volumename", "UTF8", None,),  # 7
    (8, TType.BOOL, "https", None, None,),  # 8
    (9, TType.BOOL, "http", None, None,),  # 9
    (10, TType.LIST, "resenv", (TType.STRING, "UTF8", False), None,),  # 10
)


class start_server_result(object):
    """
    Attributes:
     - success
     - e
     - r
     - s
     - n
     - i
     - f
     - o

    """

    def __init__(
        self, success=None, e=None, r=None, s=None, n=None, i=None, f=None, o=None,
    ):
        self.success = success
        self.e = e
        self.r = r
        self.s = s
        self.n = n
        self.i = i
        self.f = f
        self.o = o

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype143, _vtype144, _size142) = iprot.readMapBegin()
                    for _i146 in range(_size142):
                        _key147 = (
                            iprot.readString().decode("utf-8")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        _val148 = (
                            iprot.readString().decode("utf-8")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.success[_key147] = _val148
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = nameException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.r = ressourceException()
                    self.r.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.s = serverNotFoundException()
                    self.s.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.n = networkNotFoundException()
                    self.n.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.i = imageNotFoundException()
                    self.i.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.f = flavorNotFoundException()
                    self.f.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.o = otherException()
                    self.o.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("start_server_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for kiter149, viter150 in self.success.items():
                oprot.writeString(
                    kiter149.encode("utf-8") if sys.version_info[0] == 2 else kiter149
                )
                oprot.writeString(
                    viter150.encode("utf-8") if sys.version_info[0] == 2 else viter150
                )
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin("e", TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        if self.r is not None:
            oprot.writeFieldBegin("r", TType.STRUCT, 2)
            self.r.write(oprot)
            oprot.writeFieldEnd()
        if self.s is not None:
            oprot.writeFieldBegin("s", TType.STRUCT, 3)
            self.s.write(oprot)
            oprot.writeFieldEnd()
        if self.n is not None:
            oprot.writeFieldBegin("n", TType.STRUCT, 4)
            self.n.write(oprot)
            oprot.writeFieldEnd()
        if self.i is not None:
            oprot.writeFieldBegin("i", TType.STRUCT, 5)
            self.i.write(oprot)
            oprot.writeFieldEnd()
        if self.f is not None:
            oprot.writeFieldBegin("f", TType.STRUCT, 6)
            self.f.write(oprot)
            oprot.writeFieldEnd()
        if self.o is not None:
            oprot.writeFieldBegin("o", TType.STRUCT, 7)
            self.o.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(start_server_result)
start_server_result.thrift_spec = (
    (
        0,
        TType.MAP,
        "success",
        (TType.STRING, "UTF8", TType.STRING, "UTF8", False),
        None,
    ),  # 0
    (1, TType.STRUCT, "e", [nameException, None], None,),  # 1
    (2, TType.STRUCT, "r", [ressourceException, None], None,),  # 2
    (3, TType.STRUCT, "s", [serverNotFoundException, None], None,),  # 3
    (4, TType.STRUCT, "n", [networkNotFoundException, None], None,),  # 4
    (5, TType.STRUCT, "i", [imageNotFoundException, None], None,),  # 5
    (6, TType.STRUCT, "f", [flavorNotFoundException, None], None,),  # 6
    (7, TType.STRUCT, "o", [otherException, None], None,),  # 7
)


class start_server_with_custom_key_args(object):
    """
    Attributes:
     - flavor: Name of the  Flavor to use.
     - image: Name of the image to use.
     - servername: Name for the new server
     - metadata: Metadata for the new instance
     - diskspace: Diskspace in GB for additional volume.
     - volumename: Name of additional Volume
     - http: Boolean for http security rule
     - https: Boolean for https security rule
     - resenv

    """

    def __init__(
        self,
        flavor=None,
        image=None,
        servername=None,
        metadata=None,
        diskspace=None,
        volumename=None,
        http=None,
        https=None,
        resenv=None,
    ):
        self.flavor = flavor
        self.image = image
        self.servername = servername
        self.metadata = metadata
        self.diskspace = diskspace
        self.volumename = volumename
        self.http = http
        self.https = https
        self.resenv = resenv

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.flavor = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.image = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.servername = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.MAP:
                    self.metadata = {}
                    (_ktype152, _vtype153, _size151) = iprot.readMapBegin()
                    for _i155 in range(_size151):
                        _key156 = (
                            iprot.readString().decode("utf-8")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        _val157 = (
                            iprot.readString().decode("utf-8")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.metadata[_key156] = _val157
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.diskspace = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.volumename = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.http = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.https = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.LIST:
                    self.resenv = []
                    (_etype161, _size158) = iprot.readListBegin()
                    for _i162 in range(_size158):
                        _elem163 = (
                            iprot.readString().decode("utf-8")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.resenv.append(_elem163)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("start_server_with_custom_key_args")
        if self.flavor is not None:
            oprot.writeFieldBegin("flavor", TType.STRING, 1)
            oprot.writeString(
                self.flavor.encode("utf-8") if sys.version_info[0] == 2 else self.flavor
            )
            oprot.writeFieldEnd()
        if self.image is not None:
            oprot.writeFieldBegin("image", TType.STRING, 2)
            oprot.writeString(
                self.image.encode("utf-8") if sys.version_info[0] == 2 else self.image
            )
            oprot.writeFieldEnd()
        if self.servername is not None:
            oprot.writeFieldBegin("servername", TType.STRING, 3)
            oprot.writeString(
                self.servername.encode("utf-8")
                if sys.version_info[0] == 2
                else self.servername
            )
            oprot.writeFieldEnd()
        if self.metadata is not None:
            oprot.writeFieldBegin("metadata", TType.MAP, 4)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.metadata))
            for kiter164, viter165 in self.metadata.items():
                oprot.writeString(
                    kiter164.encode("utf-8") if sys.version_info[0] == 2 else kiter164
                )
                oprot.writeString(
                    viter165.encode("utf-8") if sys.version_info[0] == 2 else viter165
                )
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.diskspace is not None:
            oprot.writeFieldBegin("diskspace", TType.STRING, 5)
            oprot.writeString(
                self.diskspace.encode("utf-8")
                if sys.version_info[0] == 2
                else self.diskspace
            )
            oprot.writeFieldEnd()
        if self.volumename is not None:
            oprot.writeFieldBegin("volumename", TType.STRING, 6)
            oprot.writeString(
                self.volumename.encode("utf-8")
                if sys.version_info[0] == 2
                else self.volumename
            )
            oprot.writeFieldEnd()
        if self.http is not None:
            oprot.writeFieldBegin("http", TType.BOOL, 7)
            oprot.writeBool(self.http)
            oprot.writeFieldEnd()
        if self.https is not None:
            oprot.writeFieldBegin("https", TType.BOOL, 8)
            oprot.writeBool(self.https)
            oprot.writeFieldEnd()
        if self.resenv is not None:
            oprot.writeFieldBegin("resenv", TType.LIST, 9)
            oprot.writeListBegin(TType.STRING, len(self.resenv))
            for iter166 in self.resenv:
                oprot.writeString(
                    iter166.encode("utf-8") if sys.version_info[0] == 2 else iter166
                )
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(start_server_with_custom_key_args)
start_server_with_custom_key_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, "flavor", "UTF8", None,),  # 1
    (2, TType.STRING, "image", "UTF8", None,),  # 2
    (3, TType.STRING, "servername", "UTF8", None,),  # 3
    (
        4,
        TType.MAP,
        "metadata",
        (TType.STRING, "UTF8", TType.STRING, "UTF8", False),
        None,
    ),  # 4
    (5, TType.STRING, "diskspace", "UTF8", None,),  # 5
    (6, TType.STRING, "volumename", "UTF8", None,),  # 6
    (7, TType.BOOL, "http", None, None,),  # 7
    (8, TType.BOOL, "https", None, None,),  # 8
    (9, TType.LIST, "resenv", (TType.STRING, "UTF8", False), None,),  # 9
)


class start_server_with_custom_key_result(object):
    """
    Attributes:
     - success
     - e
     - r
     - s
     - n
     - i
     - f
     - o

    """

    def __init__(
        self, success=None, e=None, r=None, s=None, n=None, i=None, f=None, o=None,
    ):
        self.success = success
        self.e = e
        self.r = r
        self.s = s
        self.n = n
        self.i = i
        self.f = f
        self.o = o

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype168, _vtype169, _size167) = iprot.readMapBegin()
                    for _i171 in range(_size167):
                        _key172 = (
                            iprot.readString().decode("utf-8")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        _val173 = (
                            iprot.readString().decode("utf-8")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.success[_key172] = _val173
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = nameException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.r = ressourceException()
                    self.r.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.s = serverNotFoundException()
                    self.s.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.n = networkNotFoundException()
                    self.n.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.i = imageNotFoundException()
                    self.i.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.f = flavorNotFoundException()
                    self.f.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.o = otherException()
                    self.o.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("start_server_with_custom_key_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for kiter174, viter175 in self.success.items():
                oprot.writeString(
                    kiter174.encode("utf-8") if sys.version_info[0] == 2 else kiter174
                )
                oprot.writeString(
                    viter175.encode("utf-8") if sys.version_info[0] == 2 else viter175
                )
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin("e", TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        if self.r is not None:
            oprot.writeFieldBegin("r", TType.STRUCT, 2)
            self.r.write(oprot)
            oprot.writeFieldEnd()
        if self.s is not None:
            oprot.writeFieldBegin("s", TType.STRUCT, 3)
            self.s.write(oprot)
            oprot.writeFieldEnd()
        if self.n is not None:
            oprot.writeFieldBegin("n", TType.STRUCT, 4)
            self.n.write(oprot)
            oprot.writeFieldEnd()
        if self.i is not None:
            oprot.writeFieldBegin("i", TType.STRUCT, 5)
            self.i.write(oprot)
            oprot.writeFieldEnd()
        if self.f is not None:
            oprot.writeFieldBegin("f", TType.STRUCT, 6)
            self.f.write(oprot)
            oprot.writeFieldEnd()
        if self.o is not None:
            oprot.writeFieldBegin("o", TType.STRUCT, 7)
            self.o.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(start_server_with_custom_key_result)
start_server_with_custom_key_result.thrift_spec = (
    (
        0,
        TType.MAP,
        "success",
        (TType.STRING, "UTF8", TType.STRING, "UTF8", False),
        None,
    ),  # 0
    (1, TType.STRUCT, "e", [nameException, None], None,),  # 1
    (2, TType.STRUCT, "r", [ressourceException, None], None,),  # 2
    (3, TType.STRUCT, "s", [serverNotFoundException, None], None,),  # 3
    (4, TType.STRUCT, "n", [networkNotFoundException, None], None,),  # 4
    (5, TType.STRUCT, "i", [imageNotFoundException, None], None,),  # 5
    (6, TType.STRUCT, "f", [flavorNotFoundException, None], None,),  # 6
    (7, TType.STRUCT, "o", [otherException, None], None,),  # 7
)


class exist_server_args(object):
    """
    Attributes:
     - name

    """

    def __init__(
        self, name=None,
    ):
        self.name = name

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("exist_server_args")
        if self.name is not None:
            oprot.writeFieldBegin("name", TType.STRING, 1)
            oprot.writeString(
                self.name.encode("utf-8") if sys.version_info[0] == 2 else self.name
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(exist_server_args)
exist_server_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, "name", "UTF8", None,),  # 1
)


class exist_server_result(object):
    """
    Attributes:
     - success

    """

    def __init__(
        self, success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("exist_server_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(exist_server_result)
exist_server_result.thrift_spec = ((0, TType.BOOL, "success", None, None,),)  # 0


class create_and_deploy_playbook_args(object):
    """
    Attributes:
     - public_key
     - playbooks_information
     - openstack_id

    """

    def __init__(
        self, public_key=None, playbooks_information=None, openstack_id=None,
    ):
        self.public_key = public_key
        self.playbooks_information = playbooks_information
        self.openstack_id = openstack_id

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.public_key = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.playbooks_information = {}
                    (_ktype177, _vtype178, _size176) = iprot.readMapBegin()
                    for _i180 in range(_size176):
                        _key181 = (
                            iprot.readString().decode("utf-8")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        _val182 = {}
                        (_ktype184, _vtype185, _size183) = iprot.readMapBegin()
                        for _i187 in range(_size183):
                            _key188 = (
                                iprot.readString().decode("utf-8")
                                if sys.version_info[0] == 2
                                else iprot.readString()
                            )
                            _val189 = (
                                iprot.readString().decode("utf-8")
                                if sys.version_info[0] == 2
                                else iprot.readString()
                            )
                            _val182[_key188] = _val189
                        iprot.readMapEnd()
                        self.playbooks_information[_key181] = _val182
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.openstack_id = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("create_and_deploy_playbook_args")
        if self.public_key is not None:
            oprot.writeFieldBegin("public_key", TType.STRING, 1)
            oprot.writeString(
                self.public_key.encode("utf-8")
                if sys.version_info[0] == 2
                else self.public_key
            )
            oprot.writeFieldEnd()
        if self.playbooks_information is not None:
            oprot.writeFieldBegin("playbooks_information", TType.MAP, 2)
            oprot.writeMapBegin(
                TType.STRING, TType.MAP, len(self.playbooks_information)
            )
            for kiter190, viter191 in self.playbooks_information.items():
                oprot.writeString(
                    kiter190.encode("utf-8") if sys.version_info[0] == 2 else kiter190
                )
                oprot.writeMapBegin(TType.STRING, TType.STRING, len(viter191))
                for kiter192, viter193 in viter191.items():
                    oprot.writeString(
                        kiter192.encode("utf-8")
                        if sys.version_info[0] == 2
                        else kiter192
                    )
                    oprot.writeString(
                        viter193.encode("utf-8")
                        if sys.version_info[0] == 2
                        else viter193
                    )
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.openstack_id is not None:
            oprot.writeFieldBegin("openstack_id", TType.STRING, 3)
            oprot.writeString(
                self.openstack_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.openstack_id
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(create_and_deploy_playbook_args)
create_and_deploy_playbook_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, "public_key", "UTF8", None,),  # 1
    (
        2,
        TType.MAP,
        "playbooks_information",
        (
            TType.STRING,
            "UTF8",
            TType.MAP,
            (TType.STRING, "UTF8", TType.STRING, "UTF8", False),
            False,
        ),
        None,
    ),  # 2
    (3, TType.STRING, "openstack_id", "UTF8", None,),  # 3
)


class create_and_deploy_playbook_result(object):
    """
    Attributes:
     - success

    """

    def __init__(
        self, success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("create_and_deploy_playbook_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(create_and_deploy_playbook_result)
create_and_deploy_playbook_result.thrift_spec = (
    (0, TType.I32, "success", None, None,),  # 0
)


class get_playbook_logs_args(object):
    """
    Attributes:
     - openstack_id

    """

    def __init__(
        self, openstack_id=None,
    ):
        self.openstack_id = openstack_id

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.openstack_id = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_playbook_logs_args")
        if self.openstack_id is not None:
            oprot.writeFieldBegin("openstack_id", TType.STRING, 1)
            oprot.writeString(
                self.openstack_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.openstack_id
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_playbook_logs_args)
get_playbook_logs_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, "openstack_id", "UTF8", None,),  # 1
)


class get_playbook_logs_result(object):
    """
    Attributes:
     - success

    """

    def __init__(
        self, success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = PlaybookResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_playbook_logs_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_playbook_logs_result)
get_playbook_logs_result.thrift_spec = (
    (0, TType.STRUCT, "success", [PlaybookResult, None], None,),  # 0
)


class has_forc_args(object):
    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("has_forc_args")
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(has_forc_args)
has_forc_args.thrift_spec = ()


class has_forc_result(object):
    """
    Attributes:
     - success

    """

    def __init__(
        self, success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("has_forc_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(has_forc_result)
has_forc_result.thrift_spec = ((0, TType.BOOL, "success", None, None,),)  # 0


class get_forc_url_args(object):
    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_forc_url_args")
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_forc_url_args)
get_forc_url_args.thrift_spec = ()


class get_forc_url_result(object):
    """
    Attributes:
     - success

    """

    def __init__(
        self, success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_forc_url_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRING, 0)
            oprot.writeString(
                self.success.encode("utf-8")
                if sys.version_info[0] == 2
                else self.success
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_forc_url_result)
get_forc_url_result.thrift_spec = ((0, TType.STRING, "success", "UTF8", None,),)  # 0


class create_backend_args(object):
    """
    Attributes:
     - elixir_id
     - user_key_url
     - template
     - upstream_url

    """

    def __init__(
        self, elixir_id=None, user_key_url=None, template=None, upstream_url=None,
    ):
        self.elixir_id = elixir_id
        self.user_key_url = user_key_url
        self.template = template
        self.upstream_url = upstream_url

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.elixir_id = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.user_key_url = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.template = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.upstream_url = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("create_backend_args")
        if self.elixir_id is not None:
            oprot.writeFieldBegin("elixir_id", TType.STRING, 1)
            oprot.writeString(
                self.elixir_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.elixir_id
            )
            oprot.writeFieldEnd()
        if self.user_key_url is not None:
            oprot.writeFieldBegin("user_key_url", TType.STRING, 2)
            oprot.writeString(
                self.user_key_url.encode("utf-8")
                if sys.version_info[0] == 2
                else self.user_key_url
            )
            oprot.writeFieldEnd()
        if self.template is not None:
            oprot.writeFieldBegin("template", TType.STRING, 3)
            oprot.writeString(
                self.template.encode("utf-8")
                if sys.version_info[0] == 2
                else self.template
            )
            oprot.writeFieldEnd()
        if self.upstream_url is not None:
            oprot.writeFieldBegin("upstream_url", TType.STRING, 4)
            oprot.writeString(
                self.upstream_url.encode("utf-8")
                if sys.version_info[0] == 2
                else self.upstream_url
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(create_backend_args)
create_backend_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, "elixir_id", "UTF8", None,),  # 1
    (2, TType.STRING, "user_key_url", "UTF8", None,),  # 2
    (3, TType.STRING, "template", "UTF8", None,),  # 3
    (4, TType.STRING, "upstream_url", "UTF8", None,),  # 4
)


class create_backend_result(object):
    """
    Attributes:
     - success

    """

    def __init__(
        self, success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Backend()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("create_backend_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(create_backend_result)
create_backend_result.thrift_spec = (
    (0, TType.STRUCT, "success", [Backend, None], None,),  # 0
)


class get_backends_args(object):
    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_backends_args")
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_backends_args)
get_backends_args.thrift_spec = ()


class get_backends_result(object):
    """
    Attributes:
     - success

    """

    def __init__(
        self, success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype197, _size194) = iprot.readListBegin()
                    for _i198 in range(_size194):
                        _elem199 = Backend()
                        _elem199.read(iprot)
                        self.success.append(_elem199)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_backends_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter200 in self.success:
                iter200.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_backends_result)
get_backends_result.thrift_spec = (
    (0, TType.LIST, "success", (TType.STRUCT, [Backend, None], False), None,),  # 0
)


class get_backends_by_owner_args(object):
    """
    Attributes:
     - elixir_id

    """

    def __init__(
        self, elixir_id=None,
    ):
        self.elixir_id = elixir_id

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.elixir_id = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_backends_by_owner_args")
        if self.elixir_id is not None:
            oprot.writeFieldBegin("elixir_id", TType.STRING, 1)
            oprot.writeString(
                self.elixir_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.elixir_id
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_backends_by_owner_args)
get_backends_by_owner_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, "elixir_id", "UTF8", None,),  # 1
)


class get_backends_by_owner_result(object):
    """
    Attributes:
     - success

    """

    def __init__(
        self, success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype204, _size201) = iprot.readListBegin()
                    for _i205 in range(_size201):
                        _elem206 = Backend()
                        _elem206.read(iprot)
                        self.success.append(_elem206)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_backends_by_owner_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter207 in self.success:
                iter207.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_backends_by_owner_result)
get_backends_by_owner_result.thrift_spec = (
    (0, TType.LIST, "success", (TType.STRUCT, [Backend, None], False), None,),  # 0
)


class get_backends_by_template_args(object):
    """
    Attributes:
     - template

    """

    def __init__(
        self, template=None,
    ):
        self.template = template

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.template = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_backends_by_template_args")
        if self.template is not None:
            oprot.writeFieldBegin("template", TType.STRING, 1)
            oprot.writeString(
                self.template.encode("utf-8")
                if sys.version_info[0] == 2
                else self.template
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_backends_by_template_args)
get_backends_by_template_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, "template", "UTF8", None,),  # 1
)


class get_backends_by_template_result(object):
    """
    Attributes:
     - success

    """

    def __init__(
        self, success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype211, _size208) = iprot.readListBegin()
                    for _i212 in range(_size208):
                        _elem213 = Backend()
                        _elem213.read(iprot)
                        self.success.append(_elem213)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_backends_by_template_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter214 in self.success:
                iter214.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_backends_by_template_result)
get_backends_by_template_result.thrift_spec = (
    (0, TType.LIST, "success", (TType.STRUCT, [Backend, None], False), None,),  # 0
)


class get_backend_by_id_args(object):
    """
    Attributes:
     - id

    """

    def __init__(
        self, id=None,
    ):
        self.id = id

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_backend_by_id_args")
        if self.id is not None:
            oprot.writeFieldBegin("id", TType.I64, 1)
            oprot.writeI64(self.id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_backend_by_id_args)
get_backend_by_id_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, "id", None, None,),  # 1
)


class get_backend_by_id_result(object):
    """
    Attributes:
     - success

    """

    def __init__(
        self, success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Backend()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_backend_by_id_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_backend_by_id_result)
get_backend_by_id_result.thrift_spec = (
    (0, TType.STRUCT, "success", [Backend, None], None,),  # 0
)


class delete_backend_args(object):
    """
    Attributes:
     - id

    """

    def __init__(
        self, id=None,
    ):
        self.id = id

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("delete_backend_args")
        if self.id is not None:
            oprot.writeFieldBegin("id", TType.I64, 1)
            oprot.writeI64(self.id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(delete_backend_args)
delete_backend_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, "id", None, None,),  # 1
)


class delete_backend_result(object):
    """
    Attributes:
     - success

    """

    def __init__(
        self, success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("delete_backend_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRING, 0)
            oprot.writeString(
                self.success.encode("utf-8")
                if sys.version_info[0] == 2
                else self.success
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(delete_backend_result)
delete_backend_result.thrift_spec = ((0, TType.STRING, "success", "UTF8", None,),)  # 0


class get_templates_args(object):
    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_templates_args")
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_templates_args)
get_templates_args.thrift_spec = ()


class get_templates_result(object):
    """
    Attributes:
     - success

    """

    def __init__(
        self, success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype218, _size215) = iprot.readListBegin()
                    for _i219 in range(_size215):
                        _elem220 = {}
                        (_ktype222, _vtype223, _size221) = iprot.readMapBegin()
                        for _i225 in range(_size221):
                            _key226 = (
                                iprot.readString().decode("utf-8")
                                if sys.version_info[0] == 2
                                else iprot.readString()
                            )
                            _val227 = (
                                iprot.readString().decode("utf-8")
                                if sys.version_info[0] == 2
                                else iprot.readString()
                            )
                            _elem220[_key226] = _val227
                        iprot.readMapEnd()
                        self.success.append(_elem220)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_templates_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.MAP, len(self.success))
            for iter228 in self.success:
                oprot.writeMapBegin(TType.STRING, TType.STRING, len(iter228))
                for kiter229, viter230 in iter228.items():
                    oprot.writeString(
                        kiter229.encode("utf-8")
                        if sys.version_info[0] == 2
                        else kiter229
                    )
                    oprot.writeString(
                        viter230.encode("utf-8")
                        if sys.version_info[0] == 2
                        else viter230
                    )
                oprot.writeMapEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_templates_result)
get_templates_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.MAP, (TType.STRING, "UTF8", TType.STRING, "UTF8", False), False),
        None,
    ),  # 0
)


class get_allowed_templates_args(object):
    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_allowed_templates_args")
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_allowed_templates_args)
get_allowed_templates_args.thrift_spec = ()


class get_allowed_templates_result(object):
    """
    Attributes:
     - success

    """

    def __init__(
        self, success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype234, _size231) = iprot.readListBegin()
                    for _i235 in range(_size231):
                        _elem236 = (
                            iprot.readString().decode("utf-8")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.success.append(_elem236)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_allowed_templates_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter237 in self.success:
                oprot.writeString(
                    iter237.encode("utf-8") if sys.version_info[0] == 2 else iter237
                )
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_allowed_templates_result)
get_allowed_templates_result.thrift_spec = (
    (0, TType.LIST, "success", (TType.STRING, "UTF8", False), None,),  # 0
)


class get_templates_by_template_args(object):
    """
    Attributes:
     - template_name

    """

    def __init__(
        self, template_name=None,
    ):
        self.template_name = template_name

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.template_name = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_templates_by_template_args")
        if self.template_name is not None:
            oprot.writeFieldBegin("template_name", TType.STRING, 1)
            oprot.writeString(
                self.template_name.encode("utf-8")
                if sys.version_info[0] == 2
                else self.template_name
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_templates_by_template_args)
get_templates_by_template_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, "template_name", "UTF8", None,),  # 1
)


class get_templates_by_template_result(object):
    """
    Attributes:
     - success

    """

    def __init__(
        self, success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype241, _size238) = iprot.readListBegin()
                    for _i242 in range(_size238):
                        _elem243 = {}
                        (_ktype245, _vtype246, _size244) = iprot.readMapBegin()
                        for _i248 in range(_size244):
                            _key249 = (
                                iprot.readString().decode("utf-8")
                                if sys.version_info[0] == 2
                                else iprot.readString()
                            )
                            _val250 = (
                                iprot.readString().decode("utf-8")
                                if sys.version_info[0] == 2
                                else iprot.readString()
                            )
                            _elem243[_key249] = _val250
                        iprot.readMapEnd()
                        self.success.append(_elem243)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_templates_by_template_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.MAP, len(self.success))
            for iter251 in self.success:
                oprot.writeMapBegin(TType.STRING, TType.STRING, len(iter251))
                for kiter252, viter253 in iter251.items():
                    oprot.writeString(
                        kiter252.encode("utf-8")
                        if sys.version_info[0] == 2
                        else kiter252
                    )
                    oprot.writeString(
                        viter253.encode("utf-8")
                        if sys.version_info[0] == 2
                        else viter253
                    )
                oprot.writeMapEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_templates_by_template_result)
get_templates_by_template_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.MAP, (TType.STRING, "UTF8", TType.STRING, "UTF8", False), False),
        None,
    ),  # 0
)


class check_template_args(object):
    """
    Attributes:
     - template_name
     - template_version

    """

    def __init__(
        self, template_name=None, template_version=None,
    ):
        self.template_name = template_name
        self.template_version = template_version

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.template_name = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.template_version = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("check_template_args")
        if self.template_name is not None:
            oprot.writeFieldBegin("template_name", TType.STRING, 1)
            oprot.writeString(
                self.template_name.encode("utf-8")
                if sys.version_info[0] == 2
                else self.template_name
            )
            oprot.writeFieldEnd()
        if self.template_version is not None:
            oprot.writeFieldBegin("template_version", TType.STRING, 2)
            oprot.writeString(
                self.template_version.encode("utf-8")
                if sys.version_info[0] == 2
                else self.template_version
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(check_template_args)
check_template_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, "template_name", "UTF8", None,),  # 1
    (2, TType.STRING, "template_version", "UTF8", None,),  # 2
)


class check_template_result(object):
    """
    Attributes:
     - success

    """

    def __init__(
        self, success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype255, _vtype256, _size254) = iprot.readMapBegin()
                    for _i258 in range(_size254):
                        _key259 = (
                            iprot.readString().decode("utf-8")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        _val260 = (
                            iprot.readString().decode("utf-8")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.success[_key259] = _val260
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("check_template_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for kiter261, viter262 in self.success.items():
                oprot.writeString(
                    kiter261.encode("utf-8") if sys.version_info[0] == 2 else kiter261
                )
                oprot.writeString(
                    viter262.encode("utf-8") if sys.version_info[0] == 2 else viter262
                )
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(check_template_result)
check_template_result.thrift_spec = (
    (
        0,
        TType.MAP,
        "success",
        (TType.STRING, "UTF8", TType.STRING, "UTF8", False),
        None,
    ),  # 0
)


class add_udp_security_group_args(object):
    """
    Attributes:
     - server_id: OpenStack id of the server

    """

    def __init__(
        self, server_id=None,
    ):
        self.server_id = server_id

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.server_id = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("add_udp_security_group_args")
        if self.server_id is not None:
            oprot.writeFieldBegin("server_id", TType.STRING, 1)
            oprot.writeString(
                self.server_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.server_id
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(add_udp_security_group_args)
add_udp_security_group_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, "server_id", "UTF8", None,),  # 1
)


class add_udp_security_group_result(object):
    """
    Attributes:
     - success
     - r
     - s

    """

    def __init__(
        self, success=None, r=None, s=None,
    ):
        self.success = success
        self.r = r
        self.s = s

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.r = ressourceException()
                    self.r.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.s = serverNotFoundException()
                    self.s.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("add_udp_security_group_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.r is not None:
            oprot.writeFieldBegin("r", TType.STRUCT, 1)
            self.r.write(oprot)
            oprot.writeFieldEnd()
        if self.s is not None:
            oprot.writeFieldBegin("s", TType.STRUCT, 2)
            self.s.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(add_udp_security_group_result)
add_udp_security_group_result.thrift_spec = (
    (0, TType.BOOL, "success", None, None,),  # 0
    (1, TType.STRUCT, "r", [ressourceException, None], None,),  # 1
    (2, TType.STRUCT, "s", [serverNotFoundException, None], None,),  # 2
)


class get_servers_args(object):
    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_servers_args")
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_servers_args)
get_servers_args.thrift_spec = ()


class get_servers_result(object):
    """
    Attributes:
     - success

    """

    def __init__(
        self, success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype266, _size263) = iprot.readListBegin()
                    for _i267 in range(_size263):
                        _elem268 = VM()
                        _elem268.read(iprot)
                        self.success.append(_elem268)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_servers_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter269 in self.success:
                iter269.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_servers_result)
get_servers_result.thrift_spec = (
    (0, TType.LIST, "success", (TType.STRUCT, [VM, None], False), None,),  # 0
)


class get_servers_by_ids_args(object):
    """
    Attributes:
     - server_ids

    """

    def __init__(
        self, server_ids=None,
    ):
        self.server_ids = server_ids

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.server_ids = []
                    (_etype273, _size270) = iprot.readListBegin()
                    for _i274 in range(_size270):
                        _elem275 = (
                            iprot.readString().decode("utf-8")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.server_ids.append(_elem275)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_servers_by_ids_args")
        if self.server_ids is not None:
            oprot.writeFieldBegin("server_ids", TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.server_ids))
            for iter276 in self.server_ids:
                oprot.writeString(
                    iter276.encode("utf-8") if sys.version_info[0] == 2 else iter276
                )
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_servers_by_ids_args)
get_servers_by_ids_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, "server_ids", (TType.STRING, "UTF8", False), None,),  # 1
)


class get_servers_by_ids_result(object):
    """
    Attributes:
     - success

    """

    def __init__(
        self, success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype280, _size277) = iprot.readListBegin()
                    for _i281 in range(_size277):
                        _elem282 = VM()
                        _elem282.read(iprot)
                        self.success.append(_elem282)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_servers_by_ids_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter283 in self.success:
                iter283.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_servers_by_ids_result)
get_servers_by_ids_result.thrift_spec = (
    (0, TType.LIST, "success", (TType.STRUCT, [VM, None], False), None,),  # 0
)


class get_servers_by_bibigrid_id_args(object):
    """
    Attributes:
     - bibigrid_id

    """

    def __init__(
        self, bibigrid_id=None,
    ):
        self.bibigrid_id = bibigrid_id

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.bibigrid_id = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_servers_by_bibigrid_id_args")
        if self.bibigrid_id is not None:
            oprot.writeFieldBegin("bibigrid_id", TType.STRING, 1)
            oprot.writeString(
                self.bibigrid_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.bibigrid_id
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_servers_by_bibigrid_id_args)
get_servers_by_bibigrid_id_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, "bibigrid_id", "UTF8", None,),  # 1
)


class get_servers_by_bibigrid_id_result(object):
    """
    Attributes:
     - success

    """

    def __init__(
        self, success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype287, _size284) = iprot.readListBegin()
                    for _i288 in range(_size284):
                        _elem289 = VM()
                        _elem289.read(iprot)
                        self.success.append(_elem289)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_servers_by_bibigrid_id_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter290 in self.success:
                iter290.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_servers_by_bibigrid_id_result)
get_servers_by_bibigrid_id_result.thrift_spec = (
    (0, TType.LIST, "success", (TType.STRUCT, [VM, None], False), None,),  # 0
)


class get_cluster_info_args(object):
    """
    Attributes:
     - cluster_id

    """

    def __init__(
        self, cluster_id=None,
    ):
        self.cluster_id = cluster_id

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.cluster_id = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_cluster_info_args")
        if self.cluster_id is not None:
            oprot.writeFieldBegin("cluster_id", TType.STRING, 1)
            oprot.writeString(
                self.cluster_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.cluster_id
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_cluster_info_args)
get_cluster_info_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, "cluster_id", "UTF8", None,),  # 1
)


class get_cluster_info_result(object):
    """
    Attributes:
     - success

    """

    def __init__(
        self, success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ClusterInfo()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_cluster_info_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_cluster_info_result)
get_cluster_info_result.thrift_spec = (
    (0, TType.STRUCT, "success", [ClusterInfo, None], None,),  # 0
)


class get_server_args(object):
    """
    Attributes:
     - openstack_id: Id of the server.

    """

    def __init__(
        self, openstack_id=None,
    ):
        self.openstack_id = openstack_id

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.openstack_id = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_server_args")
        if self.openstack_id is not None:
            oprot.writeFieldBegin("openstack_id", TType.STRING, 1)
            oprot.writeString(
                self.openstack_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.openstack_id
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_server_args)
get_server_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, "openstack_id", "UTF8", None,),  # 1
)


class get_server_result(object):
    """
    Attributes:
     - success
     - e

    """

    def __init__(
        self, success=None, e=None,
    ):
        self.success = success
        self.e = e

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = VM()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = serverNotFoundException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_server_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin("e", TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_server_result)
get_server_result.thrift_spec = (
    (0, TType.STRUCT, "success", [VM, None], None,),  # 0
    (1, TType.STRUCT, "e", [serverNotFoundException, None], None,),  # 1
)


class stop_server_args(object):
    """
    Attributes:
     - openstack_id: Id of the server.

    """

    def __init__(
        self, openstack_id=None,
    ):
        self.openstack_id = openstack_id

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.openstack_id = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("stop_server_args")
        if self.openstack_id is not None:
            oprot.writeFieldBegin("openstack_id", TType.STRING, 1)
            oprot.writeString(
                self.openstack_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.openstack_id
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(stop_server_args)
stop_server_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, "openstack_id", "UTF8", None,),  # 1
)


class stop_server_result(object):
    """
    Attributes:
     - success
     - e

    """

    def __init__(
        self, success=None, e=None,
    ):
        self.success = success
        self.e = e

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = serverNotFoundException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("stop_server_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin("e", TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(stop_server_result)
stop_server_result.thrift_spec = (
    (0, TType.BOOL, "success", None, None,),  # 0
    (1, TType.STRUCT, "e", [serverNotFoundException, None], None,),  # 1
)


class create_snapshot_args(object):
    """
    Attributes:
     - openstack_id: Id of the server
     - name: Name of new Snapshot
     - elixir_id: Elixir-Id of the user who requested creation of Snapshot
     - base_tags: Tags with which the servers image is also tagged ( for connection information at the webapp)
     - description: Description of the new snapshot

    """

    def __init__(
        self,
        openstack_id=None,
        name=None,
        elixir_id=None,
        base_tags=None,
        description=None,
    ):
        self.openstack_id = openstack_id
        self.name = name
        self.elixir_id = elixir_id
        self.base_tags = base_tags
        self.description = description

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.openstack_id = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.elixir_id = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.base_tags = []
                    (_etype294, _size291) = iprot.readListBegin()
                    for _i295 in range(_size291):
                        _elem296 = (
                            iprot.readString().decode("utf-8")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.base_tags.append(_elem296)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.description = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("create_snapshot_args")
        if self.openstack_id is not None:
            oprot.writeFieldBegin("openstack_id", TType.STRING, 1)
            oprot.writeString(
                self.openstack_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.openstack_id
            )
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin("name", TType.STRING, 2)
            oprot.writeString(
                self.name.encode("utf-8") if sys.version_info[0] == 2 else self.name
            )
            oprot.writeFieldEnd()
        if self.elixir_id is not None:
            oprot.writeFieldBegin("elixir_id", TType.STRING, 3)
            oprot.writeString(
                self.elixir_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.elixir_id
            )
            oprot.writeFieldEnd()
        if self.base_tags is not None:
            oprot.writeFieldBegin("base_tags", TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.base_tags))
            for iter297 in self.base_tags:
                oprot.writeString(
                    iter297.encode("utf-8") if sys.version_info[0] == 2 else iter297
                )
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.description is not None:
            oprot.writeFieldBegin("description", TType.STRING, 5)
            oprot.writeString(
                self.description.encode("utf-8")
                if sys.version_info[0] == 2
                else self.description
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(create_snapshot_args)
create_snapshot_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, "openstack_id", "UTF8", None,),  # 1
    (2, TType.STRING, "name", "UTF8", None,),  # 2
    (3, TType.STRING, "elixir_id", "UTF8", None,),  # 3
    (4, TType.LIST, "base_tags", (TType.STRING, "UTF8", False), None,),  # 4
    (5, TType.STRING, "description", "UTF8", None,),  # 5
)


class create_snapshot_result(object):
    """
    Attributes:
     - success
     - e

    """

    def __init__(
        self, success=None, e=None,
    ):
        self.success = success
        self.e = e

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = serverNotFoundException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("create_snapshot_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRING, 0)
            oprot.writeString(
                self.success.encode("utf-8")
                if sys.version_info[0] == 2
                else self.success
            )
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin("e", TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(create_snapshot_result)
create_snapshot_result.thrift_spec = (
    (0, TType.STRING, "success", "UTF8", None,),  # 0
    (1, TType.STRUCT, "e", [serverNotFoundException, None], None,),  # 1
)


class get_limits_args(object):
    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_limits_args")
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_limits_args)
get_limits_args.thrift_spec = ()


class get_limits_result(object):
    """
    Attributes:
     - success

    """

    def __init__(
        self, success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype299, _vtype300, _size298) = iprot.readMapBegin()
                    for _i302 in range(_size298):
                        _key303 = (
                            iprot.readString().decode("utf-8")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        _val304 = (
                            iprot.readString().decode("utf-8")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.success[_key303] = _val304
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_limits_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for kiter305, viter306 in self.success.items():
                oprot.writeString(
                    kiter305.encode("utf-8") if sys.version_info[0] == 2 else kiter305
                )
                oprot.writeString(
                    viter306.encode("utf-8") if sys.version_info[0] == 2 else viter306
                )
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_limits_result)
get_limits_result.thrift_spec = (
    (
        0,
        TType.MAP,
        "success",
        (TType.STRING, "UTF8", TType.STRING, "UTF8", False),
        None,
    ),  # 0
)


class start_cluster_args(object):
    """
    Attributes:
     - public_key
     - master_instance
     - worker_instance
     - user

    """

    def __init__(
        self, public_key=None, master_instance=None, worker_instance=None, user=None,
    ):
        self.public_key = public_key
        self.master_instance = master_instance
        self.worker_instance = worker_instance
        self.user = user

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.public_key = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.master_instance = ClusterInstance()
                    self.master_instance.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.worker_instance = []
                    (_etype310, _size307) = iprot.readListBegin()
                    for _i311 in range(_size307):
                        _elem312 = ClusterInstance()
                        _elem312.read(iprot)
                        self.worker_instance.append(_elem312)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.user = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("start_cluster_args")
        if self.public_key is not None:
            oprot.writeFieldBegin("public_key", TType.STRING, 1)
            oprot.writeString(
                self.public_key.encode("utf-8")
                if sys.version_info[0] == 2
                else self.public_key
            )
            oprot.writeFieldEnd()
        if self.master_instance is not None:
            oprot.writeFieldBegin("master_instance", TType.STRUCT, 2)
            self.master_instance.write(oprot)
            oprot.writeFieldEnd()
        if self.worker_instance is not None:
            oprot.writeFieldBegin("worker_instance", TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.worker_instance))
            for iter313 in self.worker_instance:
                iter313.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.user is not None:
            oprot.writeFieldBegin("user", TType.STRING, 4)
            oprot.writeString(
                self.user.encode("utf-8") if sys.version_info[0] == 2 else self.user
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(start_cluster_args)
start_cluster_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, "public_key", "UTF8", None,),  # 1
    (2, TType.STRUCT, "master_instance", [ClusterInstance, None], None,),  # 2
    (
        3,
        TType.LIST,
        "worker_instance",
        (TType.STRUCT, [ClusterInstance, None], False),
        None,
    ),  # 3
    (4, TType.STRING, "user", "UTF8", None,),  # 4
)


class start_cluster_result(object):
    """
    Attributes:
     - success

    """

    def __init__(
        self, success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype315, _vtype316, _size314) = iprot.readMapBegin()
                    for _i318 in range(_size314):
                        _key319 = (
                            iprot.readString().decode("utf-8")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        _val320 = (
                            iprot.readString().decode("utf-8")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.success[_key319] = _val320
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("start_cluster_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for kiter321, viter322 in self.success.items():
                oprot.writeString(
                    kiter321.encode("utf-8") if sys.version_info[0] == 2 else kiter321
                )
                oprot.writeString(
                    viter322.encode("utf-8") if sys.version_info[0] == 2 else viter322
                )
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(start_cluster_result)
start_cluster_result.thrift_spec = (
    (
        0,
        TType.MAP,
        "success",
        (TType.STRING, "UTF8", TType.STRING, "UTF8", False),
        None,
    ),  # 0
)


class terminate_cluster_args(object):
    """
    Attributes:
     - cluster_id

    """

    def __init__(
        self, cluster_id=None,
    ):
        self.cluster_id = cluster_id

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.cluster_id = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("terminate_cluster_args")
        if self.cluster_id is not None:
            oprot.writeFieldBegin("cluster_id", TType.STRING, 1)
            oprot.writeString(
                self.cluster_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.cluster_id
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(terminate_cluster_args)
terminate_cluster_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, "cluster_id", "UTF8", None,),  # 1
)


class terminate_cluster_result(object):
    """
    Attributes:
     - success

    """

    def __init__(
        self, success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype324, _vtype325, _size323) = iprot.readMapBegin()
                    for _i327 in range(_size323):
                        _key328 = (
                            iprot.readString().decode("utf-8")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        _val329 = (
                            iprot.readString().decode("utf-8")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.success[_key328] = _val329
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("terminate_cluster_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for kiter330, viter331 in self.success.items():
                oprot.writeString(
                    kiter330.encode("utf-8") if sys.version_info[0] == 2 else kiter330
                )
                oprot.writeString(
                    viter331.encode("utf-8") if sys.version_info[0] == 2 else viter331
                )
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(terminate_cluster_result)
terminate_cluster_result.thrift_spec = (
    (
        0,
        TType.MAP,
        "success",
        (TType.STRING, "UTF8", TType.STRING, "UTF8", False),
        None,
    ),  # 0
)


class delete_image_args(object):
    """
    Attributes:
     - image_id: Id of image

    """

    def __init__(
        self, image_id=None,
    ):
        self.image_id = image_id

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.image_id = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("delete_image_args")
        if self.image_id is not None:
            oprot.writeFieldBegin("image_id", TType.STRING, 1)
            oprot.writeString(
                self.image_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.image_id
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(delete_image_args)
delete_image_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, "image_id", "UTF8", None,),  # 1
)


class delete_image_result(object):
    """
    Attributes:
     - success
     - e

    """

    def __init__(
        self, success=None, e=None,
    ):
        self.success = success
        self.e = e

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = imageNotFoundException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("delete_image_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin("e", TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(delete_image_result)
delete_image_result.thrift_spec = (
    (0, TType.BOOL, "success", None, None,),  # 0
    (1, TType.STRUCT, "e", [imageNotFoundException, None], None,),  # 1
)


class delete_volume_attachment_args(object):
    """
    Attributes:
     - volume_id: Id of the attached volume
     - server_id: Id of the server where the volume is attached

    """

    def __init__(
        self, volume_id=None, server_id=None,
    ):
        self.volume_id = volume_id
        self.server_id = server_id

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.volume_id = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.server_id = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("delete_volume_attachment_args")
        if self.volume_id is not None:
            oprot.writeFieldBegin("volume_id", TType.STRING, 1)
            oprot.writeString(
                self.volume_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.volume_id
            )
            oprot.writeFieldEnd()
        if self.server_id is not None:
            oprot.writeFieldBegin("server_id", TType.STRING, 2)
            oprot.writeString(
                self.server_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.server_id
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(delete_volume_attachment_args)
delete_volume_attachment_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, "volume_id", "UTF8", None,),  # 1
    (2, TType.STRING, "server_id", "UTF8", None,),  # 2
)


class delete_volume_attachment_result(object):
    """
    Attributes:
     - success
     - e

    """

    def __init__(
        self, success=None, e=None,
    ):
        self.success = success
        self.e = e

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = serverNotFoundException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("delete_volume_attachment_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin("e", TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(delete_volume_attachment_result)
delete_volume_attachment_result.thrift_spec = (
    (0, TType.BOOL, "success", None, None,),  # 0
    (1, TType.STRUCT, "e", [serverNotFoundException, None], None,),  # 1
)


class delete_volume_args(object):
    """
    Attributes:
     - volume_id

    """

    def __init__(
        self, volume_id=None,
    ):
        self.volume_id = volume_id

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.volume_id = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("delete_volume_args")
        if self.volume_id is not None:
            oprot.writeFieldBegin("volume_id", TType.STRING, 1)
            oprot.writeString(
                self.volume_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.volume_id
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(delete_volume_args)
delete_volume_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, "volume_id", "UTF8", None,),  # 1
)


class delete_volume_result(object):
    """
    Attributes:
     - success

    """

    def __init__(
        self, success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("delete_volume_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(delete_volume_result)
delete_volume_result.thrift_spec = ((0, TType.BOOL, "success", None, None,),)  # 0


class attach_volume_to_server_args(object):
    """
    Attributes:
     - openstack_id: Id of server
     - volume_id: Id of volume

    """

    def __init__(
        self, openstack_id=None, volume_id=None,
    ):
        self.openstack_id = openstack_id
        self.volume_id = volume_id

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.openstack_id = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.volume_id = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("attach_volume_to_server_args")
        if self.openstack_id is not None:
            oprot.writeFieldBegin("openstack_id", TType.STRING, 1)
            oprot.writeString(
                self.openstack_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.openstack_id
            )
            oprot.writeFieldEnd()
        if self.volume_id is not None:
            oprot.writeFieldBegin("volume_id", TType.STRING, 2)
            oprot.writeString(
                self.volume_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.volume_id
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(attach_volume_to_server_args)
attach_volume_to_server_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, "openstack_id", "UTF8", None,),  # 1
    (2, TType.STRING, "volume_id", "UTF8", None,),  # 2
)


class attach_volume_to_server_result(object):
    """
    Attributes:
     - success
     - e

    """

    def __init__(
        self, success=None, e=None,
    ):
        self.success = success
        self.e = e

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = serverNotFoundException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("attach_volume_to_server_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin("e", TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(attach_volume_to_server_result)
attach_volume_to_server_result.thrift_spec = (
    (0, TType.BOOL, "success", None, None,),  # 0
    (1, TType.STRUCT, "e", [serverNotFoundException, None], None,),  # 1
)


class check_server_status_args(object):
    """
    Attributes:
     - openstack_id: Id of the server
     - diskspace: diskspace of server(volume will be attached if server is active and diskpace >0)
     - volume_id: Id of the volume

    """

    def __init__(
        self, openstack_id=None, diskspace=None, volume_id=None,
    ):
        self.openstack_id = openstack_id
        self.diskspace = diskspace
        self.volume_id = volume_id

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.openstack_id = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.diskspace = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.volume_id = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("check_server_status_args")
        if self.openstack_id is not None:
            oprot.writeFieldBegin("openstack_id", TType.STRING, 1)
            oprot.writeString(
                self.openstack_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.openstack_id
            )
            oprot.writeFieldEnd()
        if self.diskspace is not None:
            oprot.writeFieldBegin("diskspace", TType.I32, 2)
            oprot.writeI32(self.diskspace)
            oprot.writeFieldEnd()
        if self.volume_id is not None:
            oprot.writeFieldBegin("volume_id", TType.STRING, 3)
            oprot.writeString(
                self.volume_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.volume_id
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(check_server_status_args)
check_server_status_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, "openstack_id", "UTF8", None,),  # 1
    (2, TType.I32, "diskspace", None, None,),  # 2
    (3, TType.STRING, "volume_id", "UTF8", None,),  # 3
)


class check_server_status_result(object):
    """
    Attributes:
     - success
     - e
     - r

    """

    def __init__(
        self, success=None, e=None, r=None,
    ):
        self.success = success
        self.e = e
        self.r = r

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = VM()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = serverNotFoundException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.r = ressourceException()
                    self.r.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("check_server_status_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin("e", TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        if self.r is not None:
            oprot.writeFieldBegin("r", TType.STRUCT, 2)
            self.r.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(check_server_status_result)
check_server_status_result.thrift_spec = (
    (0, TType.STRUCT, "success", [VM, None], None,),  # 0
    (1, TType.STRUCT, "e", [serverNotFoundException, None], None,),  # 1
    (2, TType.STRUCT, "r", [ressourceException, None], None,),  # 2
)


class setUserPassword_args(object):
    """
    Attributes:
     - user: Elixir-Id of the user which wants to set a password
     - password: New password

    """

    def __init__(
        self, user=None, password=None,
    ):
        self.user = user
        self.password = password

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.user = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.password = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("setUserPassword_args")
        if self.user is not None:
            oprot.writeFieldBegin("user", TType.STRING, 1)
            oprot.writeString(
                self.user.encode("utf-8") if sys.version_info[0] == 2 else self.user
            )
            oprot.writeFieldEnd()
        if self.password is not None:
            oprot.writeFieldBegin("password", TType.STRING, 2)
            oprot.writeString(
                self.password.encode("utf-8")
                if sys.version_info[0] == 2
                else self.password
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(setUserPassword_args)
setUserPassword_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, "user", "UTF8", None,),  # 1
    (2, TType.STRING, "password", "UTF8", None,),  # 2
)


class setUserPassword_result(object):
    """
    Attributes:
     - success
     - e

    """

    def __init__(
        self, success=None, e=None,
    ):
        self.success = success
        self.e = e

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = otherException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("setUserPassword_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRING, 0)
            oprot.writeString(
                self.success.encode("utf-8")
                if sys.version_info[0] == 2
                else self.success
            )
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin("e", TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(setUserPassword_result)
setUserPassword_result.thrift_spec = (
    (0, TType.STRING, "success", "UTF8", None,),  # 0
    (1, TType.STRUCT, "e", [otherException, None], None,),  # 1
)


class resume_server_args(object):
    """
    Attributes:
     - openstack_id: Id of the server

    """

    def __init__(
        self, openstack_id=None,
    ):
        self.openstack_id = openstack_id

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.openstack_id = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("resume_server_args")
        if self.openstack_id is not None:
            oprot.writeFieldBegin("openstack_id", TType.STRING, 1)
            oprot.writeString(
                self.openstack_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.openstack_id
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(resume_server_args)
resume_server_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, "openstack_id", "UTF8", None,),  # 1
)


class resume_server_result(object):
    """
    Attributes:
     - success
     - e

    """

    def __init__(
        self, success=None, e=None,
    ):
        self.success = success
        self.e = e

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = serverNotFoundException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("resume_server_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin("e", TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(resume_server_result)
resume_server_result.thrift_spec = (
    (0, TType.BOOL, "success", None, None,),  # 0
    (1, TType.STRUCT, "e", [serverNotFoundException, None], None,),  # 1
)


class create_volume_args(object):
    """
    Attributes:
     - volume_name: Name of volume
     - diskspace: Diskspace in GB for new volume
     - metadata: Metadata for the new volume

    """

    def __init__(
        self, volume_name=None, diskspace=None, metadata=None,
    ):
        self.volume_name = volume_name
        self.diskspace = diskspace
        self.metadata = metadata

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.volume_name = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.diskspace = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.metadata = {}
                    (_ktype333, _vtype334, _size332) = iprot.readMapBegin()
                    for _i336 in range(_size332):
                        _key337 = (
                            iprot.readString().decode("utf-8")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        _val338 = (
                            iprot.readString().decode("utf-8")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.metadata[_key337] = _val338
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("create_volume_args")
        if self.volume_name is not None:
            oprot.writeFieldBegin("volume_name", TType.STRING, 1)
            oprot.writeString(
                self.volume_name.encode("utf-8")
                if sys.version_info[0] == 2
                else self.volume_name
            )
            oprot.writeFieldEnd()
        if self.diskspace is not None:
            oprot.writeFieldBegin("diskspace", TType.I32, 2)
            oprot.writeI32(self.diskspace)
            oprot.writeFieldEnd()
        if self.metadata is not None:
            oprot.writeFieldBegin("metadata", TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.metadata))
            for kiter339, viter340 in self.metadata.items():
                oprot.writeString(
                    kiter339.encode("utf-8") if sys.version_info[0] == 2 else kiter339
                )
                oprot.writeString(
                    viter340.encode("utf-8") if sys.version_info[0] == 2 else viter340
                )
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(create_volume_args)
create_volume_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, "volume_name", "UTF8", None,),  # 1
    (2, TType.I32, "diskspace", None, None,),  # 2
    (
        3,
        TType.MAP,
        "metadata",
        (TType.STRING, "UTF8", TType.STRING, "UTF8", False),
        None,
    ),  # 3
)


class create_volume_result(object):
    """
    Attributes:
     - success
     - r

    """

    def __init__(
        self, success=None, r=None,
    ):
        self.success = success
        self.r = r

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.r = ressourceException()
                    self.r.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("create_volume_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRING, 0)
            oprot.writeString(
                self.success.encode("utf-8")
                if sys.version_info[0] == 2
                else self.success
            )
            oprot.writeFieldEnd()
        if self.r is not None:
            oprot.writeFieldBegin("r", TType.STRUCT, 1)
            self.r.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(create_volume_result)
create_volume_result.thrift_spec = (
    (0, TType.STRING, "success", "UTF8", None,),  # 0
    (1, TType.STRUCT, "r", [ressourceException, None], None,),  # 1
)


class reboot_server_args(object):
    """
    Attributes:
     - server_id: Id of the server
     - reboot_type: HARD or SOFT

    """

    def __init__(
        self, server_id=None, reboot_type=None,
    ):
        self.server_id = server_id
        self.reboot_type = reboot_type

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.server_id = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.reboot_type = (
                        iprot.readString().decode("utf-8")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("reboot_server_args")
        if self.server_id is not None:
            oprot.writeFieldBegin("server_id", TType.STRING, 1)
            oprot.writeString(
                self.server_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.server_id
            )
            oprot.writeFieldEnd()
        if self.reboot_type is not None:
            oprot.writeFieldBegin("reboot_type", TType.STRING, 2)
            oprot.writeString(
                self.reboot_type.encode("utf-8")
                if sys.version_info[0] == 2
                else self.reboot_type
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(reboot_server_args)
reboot_server_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, "server_id", "UTF8", None,),  # 1
    (2, TType.STRING, "reboot_type", "UTF8", None,),  # 2
)


class reboot_server_result(object):
    """
    Attributes:
     - success
     - e

    """

    def __init__(
        self, success=None, e=None,
    ):
        self.success = success
        self.e = e

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = serverNotFoundException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("reboot_server_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin("e", TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(reboot_server_result)
reboot_server_result.thrift_spec = (
    (0, TType.BOOL, "success", None, None,),  # 0
    (1, TType.STRUCT, "e", [serverNotFoundException, None], None,),  # 1
)
fix_spec(all_structs)
del all_structs
